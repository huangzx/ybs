#!/bin/bash
#
#   ybs-scanpackages -- create Packages index files  
#
#   Copyright © 2012 ivali.com
#   Maintainer: Zhongxin Huang <zhongxin.huang@gmail.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

. /usr/lib/ybs/funcs

filelist_all="/tmp/filelist-all"
filelist_stable="/tmp/filelist-stable"
filelist_testing="/tmp/filelist-testing"
xml_stable="updates/stable.xml"
xml_testing="updates/testing.xml"
xml_removed="updates/removed.xml"

show_usage() {
	cat <<EOF
$0 - create packages index files

Usage: $0 binary-dir

$0 sorts through a tree of YPK binary packages and creates some xml files, used by yget, to tell the user what packages are available  for installation.

EOF
}

find_newest() {
	local newest="$1"
	local file

	for file in $@; do
		atom_cmp $newest $file
		if [ $? -eq 2 ]; then 
			 newest=$file
		fi
	done

	echo $newest
}

find_ypk() {
	local dir all
	
	find -type f -name "*.ypk" |sort -u >$filelist_all
	
	[ "x$(cat $filelist_all)" = "x" ] && die "Not any YPK package found."

	[ -f filelist.txt ] || touch filelist.txt

	if ! diff filelist.txt $filelist_all -ur; then
		read -p "Do you want to continue? [Y/n]" ask
		case $ask in
			[Nn]o|[Nn]) exit 1 ;;
				*)
		esac
	fi

	>$filelist_stable
	find -type d -name "stable" |sort -u |while read dir; do
		all=$(find $dir -type f -name "*.ypk" |sort -u |xargs)
		find_newest $all >>$filelist_stable
	done

	>$filelist_testing
	find -type d -name "testing" |sort -u |while read dir; do
		all=$(find $dir -type f -name "*.ypk" |sort -u |xargs)
		find_newest $all >>$filelist_testing
	done
	
	# 删除空行
	sed -i '/^$/d' $filelist_stable $filelist_testing $filelist_all

	echo "all: $(wc -l $filelist_all |awk '{print $1}')"          >filelist.txt 
	echo "stable: $(wc -l $filelist_stable |awk '{print $1}')"   >>filelist.txt
	echo "testing: $(wc -l $filelist_testing |awk '{print $1}')" >>filelist.txt
	cat $filelist_all >>filelist.txt
}

get_info() {
	local ypk="$1"
	local xml="$2"

	if [ ! -f "$xml" ]; then
		local size=$(du "$ypk" -sb |awk '{print $1}')
		local sha1=$(sha1sum "$ypk" |awk '{print $1}')
		tar xf "$ypk" pkginfo
		tar xf pkginfo control.xml --to-command='cat' \
			    |sed -e '1d' -e '2d' -e '$d' -e '/<uri>/d' \
			    |sed -e '/\<build_date\>/a\   <size>'"$size"'<\/size>' -e '/\<build_date\>/a\   <sha>'"$sha1"'<\/sha>' \
			    -e '/\<build_date\>/a\   <uri>'"${ypk##./}"'<\/uri>'
		rm pkginfo
	else
		cat $xml |sed -e '1d' -e '2d' -e '$d' -e '/<uri>/d' \
		         |sed -e '/\<build_date\>/a\   <uri>'"${ypk##./}"'<\/uri>'
	fi
}

merge_info() {
	local filelist="$1"
	local xmlfile="$2"

	echo '<?xml version="1.0" encoding="UTF-8"?>' >$xmlfile
	echo '<PackageInfo>' >>$xmlfile

	cat $filelist |while read ypk; do 
		xml=${ypk%.ypk}.xml
		if [ ! -f "$xml" ]; then
			echo '<?xml version="1.0" encoding="UTF-8"?>' >$xml
			echo '<PackageInfo>' >>$xml
			get_info ${ypk} >>$xml
			echo '</PackageInfo>' >>$xml
		fi
		get_info ${ypk} ${xml} >>$xmlfile
	done

	echo '</PackageInfo>' >>$xmlfile
	
}

check_xml() {
	local xml="$1"

	if ! xml fo $xml >/dev/null; then
		echo "* $xml is broken."
		exit 0
	fi
}

remove_info() {
	local xmlfile="$1"
	removes=""
	echo '<?xml version="1.0" encoding="UTF-8"?>' >$xmlfile
	echo '<PackageInfo>' >>$xmlfile

	for i in $removes; do
        	cat >>$xmlfile <<OOO
<Package name="$i">
	<version></version>
	<delete>all</delete>
</Package>
<Package name="$i-dev">
	<version></version>
	<delete>all</delete>
</Package>
OOO
	done

	echo '</PackageInfo>' >>$xmlfile
}

final() {
	# 目前，yget 只认解压后的文件为 update.xml
	cp stable.xml update.xml
	tar cJf stable.tar.xz update.xml
	
	cp testing.xml update.xml
	tar cJf testing.tar.xz update.xml
	
	#cp removed.xml update.xml
	#tar cJf removed.tar.xz update.xml

	rm update.xml

	>updates.list

	for i in testing.tar.xz stable.tar.xz; do
		name=${i}
		date=$(date +%s)
		sha1=$(sha1sum $name |awk '{print $1}')
		echo "$name $date $sha1"  >>updates.list
		sleep 1
	done

	date +%s >updates.date
}

# main
#

if ! which ypkg >/dev/null 2>/dev/null; then
	die " ypkg is required, please install ypkg2"
fi

if ! which diff >/dev/null 2>/dev/null; then
	die " diff is required, please install diffutils"
fi

case x$1 in
	x*h|x*help) show_usage
	            exit 0
esac

case x$# in 
	x0) YPK_DEST=$YPK_DEST;;
	x1) [ -d $(readlink -f $1) ] && YPK_DEST=$(readlink -f $1);;
	x2|*) show_usage
	    exit 0
esac

if [ ! -d $YPK_DEST ]; then
	die " $YPK_DEST not found."
fi

START_TIME="$(date)"

# 找出所有的 ypk 包，多个的话，只列出最大版本
# 分支是：stable 和 testing
cd $YPK_DEST                 
mkdir -p $YPK_DEST/updates/
ymsg "* YPK package binary-dir: $YPK_DEST"
ymsg "* YPK package index-dir: $YPK_DEST/updates"
find_ypk

# 生成各个分支的 xml 文件，包含所含 ypk 包的信息
merge_info $filelist_stable $xml_stable
check_xml $xml_stable

merge_info $filelist_testing  $xml_testing
check_xml $xml_testing

#remove_info $xml_removed

# 生成更新文件
cd $YPK_DEST/updates/
final

echo "Begin with  --> $START_TIME"
echo "End up with --> $(date)"

# End of file
