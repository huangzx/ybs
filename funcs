
if [ "xLANG" = "x" ]; then
	export LANG="zh_CN.UTF-8"
fi

export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/bin"

## -------------------- colourful print --------------------
## ANSI Foreground color codes:
## 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white 39=default
## ANSI Background color codes:
## 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white 49=default
COLOR_RED=$(    echo -e "\e[31;49m" )
COLOR_GREEN=$(  echo -e "\e[32;49m" )
COLOR_YELLO=$(  echo -e "\e[33;49m" )
COLOR_BLUE=$(   echo -e "\e[34;49m" )
COLOR_MAGENTA=$(echo -e "\e[35;49m" )
COLOR_CYAN=$(   echo -e "\e[36;49m" )
COLOR_WHILE=$(   echo -e "\033[1m" )
COLOR_RESET=$(  echo -e "\e[0m"     )
      
# Msg argv: "$str"
msg()  { echo "$@";                               }
rmsg() { echo "${COLOR_RED}$*${COLOR_RESET}";     }
gmsg() { echo "${COLOR_GREEN}$*${COLOR_RESET}";   }
ymsg() { echo "${COLOR_YELLO}$*${COLOR_RESET}";   }
bmsg() { echo "${COLOR_BLUE}$*${COLOR_RESET}";    }
mmsg() { echo "${COLOR_MAGENTA}$*${COLOR_RESET}"; }
cmsg() { echo "${COLOR_CYAN}$*${COLOR_RESET}";    }
wmsg() { echo "${COLOR_WHILE}$*${COLOR_RESET}";   }
					
# Colourful print without "\n"
msg_()  {  msg "$@" | tr -d '\n'; }
rmsg_() { rmsg "$@" | tr -d '\n'; }
gmsg_() { gmsg "$@" | tr -d '\n'; }
ymsg_() { ymsg "$@" | tr -d '\n'; }
bmsg_() { bmsg "$@" | tr -d '\n'; }
mmsg_() { mmsg "$@" | tr -d '\n'; }
cmsg_() { cmsg "$@" | tr -d '\n'; }
wmsg_() { wmsg "$@" | tr -d '\n'; }

#
# Path defines
YPVERSION="2.0"
YPPATH="/var/ybs"
YPPATH_LIB="$YPPATH/pbslib"
YPPATH_SOURCE="$YPPATH/sources"
YPPATH_SCRIPT="$YPPATH_LIB"
YPPATH_FIELD="/tmp/ybs"

YPKPATH="/var/ypkg"
YPPATH_UNI="$YPKPATH/packages/universe"
YPPATH_LOCAL_UNI="$YPKPATH/local/universe"

YPPATH_DB="$YPKPATH/db"
YPPATH_WORLD="$YPPATH_DB/world"

#
PACK_SUFFIX="ypk"

#
CPIO="/bin/cpio"
#CPIO="/usr/bin/bsdcpio"
XZ="/usr/bin/xz"

#
CHECK_TOOLS="md5sum sha1sum sha256sum"

#
YLMFOS="YLMFOS"

#
DOWNLOAD_TOOL="wget"
WGET_OPTIONS="--tries=3 --retry-connrefused --wait=2"
DOWNLOAD_TOOL="curl"
CURL_OPTIONS="-L"

#
WORLD_LOCKFILE="/tmp/.ypkg_lock"
UNI_LOCKFILE="/tmp/.ybs_lock"

#
pkgdata="pkgdata"
pkginfo="pkginfo"
control="control.xml"
filelist="filelist"

#
blank_funcs () {
	DESCRIPTION=""
	COMMENTS=""
	HOMEPAGE=""
	REPO=""
	YARCH="$(uname -m)"
	LICENSE=""
	PRIORITY=""
	PACKAGER=""
	SRC_URI=""
	CHECKSUM=""
	RDEPEND=""
	BDEPEND=""
	RECOMMENDED=""
	CONFLICT=""
	NOTES=""
	OPIONAL=""
	PROVIDE=""
	INSTALL=""
	OPTIONS=""
	
	INAME=""
	CATEGORY=""
	VERSION=""
	PRIORITY=""
	TYPE=""
	INSTALL_SIZE=""
	BUILD_TIME=""
	BIN_URI=""
	PACK_SIZE=""
	INSTALL=""
	SHA=""
	NAME=""
	BRIEF=""
	SPECIFICATION=""
	if [ "x$1" = "xpbs" ];then
		pbs_unpack() { :
		}
		pbs_patch() { :
		}
		pbs_config() { : 
		}
		pbs_build() { : 
		}
		pbs_check() { : 
		}
		pbs_install() { : 
		}
	fi
	[ "x$1" = "xdesc" ] && :
}

#
#
file_is_exist () {
	[ -f "$1" ] && return 0 || return 1
}


#
# Check root
#
check_root () {
	if [ "x$UID" != "x0" ];then
	        rmsg "* You must be root to run this script."
        	ymsg "* Try: sudo $0 $*"
       		exit 1
	fi
}

#
# Smmation
# 
summation() {
	if [ "x$1" = "x" ];then
		msg "* summation: you must specify a list of digit"
		msg "* i.e. 'summation 1 2 3' "
		return 1
	fi
        local sum=0
	while [ "x$1" != "x" ]; do
		local tmp=$1
		let "sum=sum+tmp"
		shift
	done
	echo $sum
	return 0
}

# $1 - name
# $2 - version
#
is_installed () {
	if [ "x$1" = "x" ];then
		msg "* is_installed: you must specify package name and version."
		msg "* i.e. 'is_installed leafpad' or 'is_installed leafpad 0.8.18.1'"
		return 1
	fi
        local N=$1
        local V=$2
        local listfile
        if [ "x$V" = "x" ]; then
	        listfile=$(ls $YPPATH_DB/$N/${N}_*.list 2>/dev/null)
	else
	        listfile=$(ls $YPPATH_DB/$N/${N}_$V.list 2>/dev/null)
	fi
	[ "x$listfile" != "x" ] && return 0 || return 1
}

#
# Get_value from xml file
#
get_value () {
	local element=$1
	local file=$2
	local value=
	case $element in
		size) value="$(grep "<$element>" $file |head -n1)" ;;
		   *) value="$(grep "<$element>" $file |sort -u)"
	esac
	value=${value//<$element>/}
	value=${value//<\/$element>/}
	value=${value//,/ }
	echo $value
}


#
get_abspath () {
	local file="$1"
	if [ ! -h "$file" ]; then
		 file=$(readlink -f "$file")
	else
		file=$(cd $(dirname $file) 2>/dev/null; pwd)/${file##*/}
	fi
	echo "$file"
}

#
# If $2 in $1 return 0, else return 1
#
str_isIn() {
	if [ "x$2" = "x" ];then
		msg "* str_isIn: you must specify at least two strings."
		msg "* i.e. 'str_isIn \"a b c\" b'"
		return 1
	fi
	local string=($1)
	local substring="$2"

	for i in ${string[@]}; do
		if [ "x$i" = "x$substring" ]; then
			return 0
		fi
	done

	return 1
}

#
#
err_check() {
	if [ $? != 0 ]; then
		rmsg "$1"
		exit 1
	fi
}

#
#
atom_parse() {
	T=""
	N=""
	V=""
	R=""
	PBSDIR=""
	local atom
	local string="$1"

	if [ "x${string##*.}" = "xpbs" ]; then
		local pbsfile="$(readlink -f $string)"
		if [ -f "$pbsfile" ]; then
			PBSDIR="${pbsfile%/*.pbs}"
			# filesdir contains patchs and user-defined files 
			filesdir="$PBSDIR"/files/
		fi
	fi

	if echo "$string" |grep -q "/"; then
		# /var/ybs/pbslib/net-ftp/lftp/lftp_4.3.3.pbs
		if echo "$string" |grep -q "$YPPATH_LIB"; then
			atom=${string##*/}
			T=${string%/*}
			T=${T%/*}
			T=${T##*/}
			string="$atom"
		fi
	
		# net-ftp/lftp_4.3.3.pbs
		if echo "$string" |grep ^[a-z] |grep -q "/"; then
			T=${string%%/*}
			atom=${string##$T/}
			string=$atom
		fi
		[ "x$atom" = "x" ] && string=${string##*/}
	fi

	case x${string##*.} in
		xpbs)           
 	  atom="${string%.pbs}" ;;
		x$PACK_SUFFIX)     
	  [ "x$YARCH" != "x" ] && atom="${string%-$YARCH.$PACK_SUFFIX}" || atom="${string%.$PACK_SUFFIX}" ;;
		xlist)	
	  atom="${string%.list}" ;;
		xdesc)	
	  atom="${string%.desc}" ;;
		*)      
 	  atom="$string"
	esac

	# Only digit
	if [ "x$(echo $atom |tr -d '[:digit:]' |tr -d '.' |tr -d '-')" = "x" ]; then
		atom=foo_$atom
	fi

	[ "x$ARCH" = "x" ] && ARCH="$(uname -m)"

	atom=${atom%-$ARCH}
	atom=${atom%-any}

	# cairo(>=1.6) x11-libs/cairo(>=1.6)
	if echo $atom |grep \( |grep -q \); then
		N=${atom%%(*)}
		VR="${atom##$N}"
		VR=$(echo $VR |tr -d '[:blank:]')
		return 0
	fi

	N=${atom%%_[0-9]*}
	N=${N%%_}
	VR=${atom#$N}
	VR=${VR#_}
	#V=${VR%%-[a-zA-z]*}
	V=${VR%%-*}
	R=${VR##$V}
}

#
# Compare 2 atoms
# 1、linux_2.6.9.pbs and linux_2.6.10.pbs
# 2、2.6.9 2.6.10
# 3、/var/ybs/pbslib/app-editors/leafpad/leafpad_0.8.17.pbs /var/ybs/pbslib/app-editors/leafpad/leafpad_0.8.18.pbs
# 4、1.2.3 3.2.1
# the former > the latter, return 1
# the former < the latter, return 2
# the former = the latter, return 0
#
atom_cmp() {
	local string1="$1"
	local string2="$2"
	local v1 v2 

	string1=${string1##*_}
	v1=${string1%.pbs}
	v1=$(echo $v1 |tr '[A-Z]' '[a-z]')

	string2=${string2##*_}
	v2=${string2%.pbs}
	v2=$(echo $v2 |tr '[A-Z]' '[a-z]')

	# Compare version
	# alpha < beta < rc 
	
	if [ "x$v1" = "x$v2" ] || test $v1 -eq $v2 2>/dev/null;then
		return 0
	fi

	local a=($(echo $v1 |awk -F- '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	local b=($(echo $v2 |awk -F- '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	[ "1${#a[@]}" -lt "1${#b[@]}" ] && maxnum=${#b[@]} || maxnum=${#a[@]}
	
	for ((i=0; i<maxnum; i++)); do
		a=${a[i]} 
		b=${b[i]}
		# Only alpha
		aoa=$(echo $a |tr -d '[:digit:]' |tr -d '[:punct:]')
		boa=$(echo $b |tr -d '[:digit:]' |tr -d '[:punct:]')
		
		case $aoa$boa in
			
			# 1.2.3 3.2.1
			"")	
			[ "x$a" = "x$b" ] && continue
				v1=$a.
				v2=$b.
			while true; do
				a=${v1%%.*}
				b=${v2%%.*}
				[ "$a"0 -gt "$b"0 ] && return 1
				[ "$a"0 -lt "$b"0 ] && return 2
				v1="${v1#*.}"
				v2="${v2#*.}"
			done
			continue ;;
			
			# "" rc1 
			# "" beta1
			# "" alpha1
			rc|beta|alpha)
				[ "x$aoa" = "x" ] && return 1
				[ "x$boa" = "x" ] && return 2
				continue ;;
			
			# "" ylmf1 
			ylmf)
				[ "x$b" != "x" ]  && return 2
				[ "x$a" != "x" ]  && return 1
				[ "x$aoa" = "x" ] && return 2
				[ "x$boa" = "x" ] && return 1
				continue 	;;

			# rc1  rc2 
				rcrc)
				a=${a##rc}
				b=${b##rc}
				[ "1$a" -gt "1$b" ] && return 1
				[ "1$a" -lt "1$b" ] && return 2
				continue 	;;
				
			# beta1 beta2 
				betabeta)
				a=${a##beta}
				b=${b##beta}
				[ "1$a" -gt "1$b" ] && return 1
				[ "1$a" -lt "1$b" ] && return 2
				continue 	;;
			
			# alpha1  alpha2 
				alphaalpha)
				a=${a##alpha}
				b=${b##alpha}
				[ "1$a" -gt "1$b" ] && return 1
				[ "1$a" -lt "1$b" ] && return 2
				continue 	;;
			
			# ylmf1 ylmf2
				ylmfylmf)
				a=${a##ylmf}
				b=${b##ylmf}
				[ "1$a" -gt "1$b" ] && return 1
				[ "1$a" -lt "1$b" ] && return 2
				continue 	;;
			
			# rc1 beta1
			# beta1 rc1
				rcbeta|betarc)
				a=${a##rc*}
				[ "x$a" = "x" ] && return 1
				a=${a##beta*}
				[ "x$a" = "x" ] && return 2
				continue	;;
			
			# rc1 alpha1
			# alpha1 rc1
				rcalpha|alpharc)
				a=${a##rc*}
				[ "x$a" = "x" ] && return 1
				a=${a##alpha*}
				[ "x$a" = "x" ] && return 2
				continue	;;
			
			# beta1 alpha1
			# alpha1 beta1
				betaalpha|alphabeta)
				a=${a##beta*}
				[ "x$a" = "x" ] && return 1
				a=${a##alpha*}
				[ "x$a" = "x" ] && return 2
				continue  	;;
			
			# rc1 ylmf1
			# ylmf1 rc1
				rcylmf|ylmfrc)
				a=${a##rc*}
				[ "x$a" = "x" ] && return 2
				a=${a##ylmf*}
				[ "x$a" = "x" ] && return 1
				continue	;;
			
			# beta1 ylmf1
			# ylmf1 beta1
				betaylmf|ylmfbeta)
				a=${a##beta*}
				[ "x$a" = "x" ] && return 2
				a=${a##ylmf*}
				[ "x$a" = "x" ] && return 1
				continue	;;
			
			# alpha ylmf1
			# ylmf1 alpha1
				alphaylmf|ylmfalpha)
				a=${a##alpha*}
				[ "x$a" = "x" ] && return 2
				a=${a##ylmf*}
				[ "x$a" = "x" ] && return 1
				continue	;;
			#
				*)
				[ "x$a" = "x$b" ] && continue
				v1=$a.
				v2=$b.
				while true; do
					a=${v1%%.*}
					b=${v2%%.*}
					a=$(echo $a |tr -d '[:alpha:]')
					b=$(echo $b |tr -d '[:alpha:]')
					[ "$a"0 -gt "$b"0 ] && return 1
					[ "$a"0 -lt "$b"0 ] && return 2
					v1="${v1#*.}"
					v2="${v2#*.}"
				done
					continue ;;
				esac
	done
	return 0
}

#
# Split csv line. 
csv_split() {
	count=0
	local retv=$1
	unset value

	while [ -n "$retv" ]; do
		value[$count]=${retv%%,*}

		retv=${retv#${value[$count]}}
		retv=${retv#,}
		let "count++"
	done
}

#
# Search packages
#

#
# List all pack types
ypkg_get_types() {
	ypkg_types=`ls $YPPATH_LIB 2>/dev/null`
}

#
#
ypkg_get_packages() {
	ypkg_packs=`ls $YPPATH_LIB/$1 2>/dev/null`
}

#
# $1 $T 
# $2 $N
# $3 $V$R (this is the newest version) 
#
ypkg_searchInstalled() {
	local pkgtype=$1
	local pkgname=$2
	local pkgver=$3

	INSTALL_STATUS=$(yget2 --show $pkgname |grep Status |head -n1 |awk '{print $2}')
	
	case "x$INSTALL_STATUS" in
	 	x[IUD])
	   	  	INSTALL_TIME=$(yget2 --show $pkgname |grep Install_date |head -n1 |awk '{print $2" "$3}')
			INSTALL_VERSION=$(yget2 --show $pkgname |grep Version |head -n1 |awk '{print $2}')
			new=$pkgver
			old=$INSTALL_VERSION
			# Compare 2 versions
			# Return 0 if same.
			# Return 1 if $1 is grater than $2
			# Return 2 if $1 is lesser then $2
	       		atom_cmp $old $new
			case $? in
				1) 
				   INSTALL_STATUS="downgrade"
				   gmsg_ "[D] "  ;;
			        2) 
				   INSTALL_STATUS="upgrade"
				   gmsg_ "[U] " ;; 
				0) 
				   INSTALL_STATUS="installed"
				   gmsg_ "[I] "
			esac 
			echo "$(wmsg $pkgtype/$pkgname)"
			echo -e "\t$(gmsg Installed:) $(ymsg $INSTALL_VERSION) $INSTALL_TIME" ;;
	  	    *) 
			msg_ "[*] "
			echo "$(wmsg $pkgtype/$pkgname)"
	   		echo -e "\t$(gmsg "Installed:") None"
	  		INSTALL_STATUS="uninstall"
	esac
}

#
#
allver_msg() {
	local pbsfile
	local msg
	local extra="$BUILD_TIME $INSTALL_SIZE $PACK_SIZE"

	for pbsfile in $ALL_PBSFILE; do 
		atom_parse $pbsfile
		. $pbsfile
		case $REPO in
		        [Tt]esting) repo="t"  ;;
		         [Ss]table) repo="s" ;;
   	               [Uu]nusable) repo="u" ;;
                                 *) repo="s"
		esac
		[ "x$msg" = "x" ] && msg="$(mmsg $V$R[$repo]) $extra" || msg+=" | $(mmsg $V$R[$repo]) $extra"
	done
	echo $msg
}

#
#
ypkg_search() {
	local string="$1"
	local record=(AA)
	local pbsfile

	if ! ypkg_getpbsfile "$string" all; then
		rmsg "* $string not found."
		return 1
	fi
	
	for pbsfile in $ALL_PBSFILE; do
		atom_parse "$pbsfile"
		ypkg_getpbsfile $T/$N name

		str_isIn "${record[@]}" "$T/$N" && continue
		record[$count]="$T/$N"
	
		ypkg_searchInstalled $T $N $V$R

		echo -e "\t$(gmsg "Available:") $(allver_msg)"
		. $NEWEST
		echo -e "\t$(gmsg "Homepage:") $HOMEPAGE"
		echo -e "\t$(gmsg "Description:") $DESCRIPTION"
		echo 

		blank_funcs
	done
}

#
# Download packeage
#
do_download () {
	local uri="$1"
	local fname="$2"
	local target="$YPPATH_SOURCE/$fname.tmp"
	local wget="wget $WGET_OPTIONS"
	local curl="curl $CURL_OPTIONS"

	msg ">>> Downloading: ${uri}"
	case $DOWNLOAD_TOOL in
		wget)
		if [ "x$(echo $uri |cut -c 1-5)" == "xhttps" ];then	
			$wget --no-check-certificate $uri -O "$target" && return 0
		else
			$wget $uri -O "$target" && return 0
		fi	;;
		curl)
			$curl $uri -o "$target" && return 0
	esac

	return 1
}

# Check and download package
# $1 is URL
# $2 is local file name
# $3 is checksum value, md5sum/sha1sum/sha256sum, default is md5sum
#
check_and_download_raw() {
	local uri=$1
	local fname=$2
	local checksum=$3
	local download
	local target="${YPPATH_SOURCE}/${fname}"

	#
	case ${uri%%:*} in
		svn)
		cd ${YPPATH_SOURCE}
		local name="$N"
		cd $name && svn update || svn checkout ${1} "$N" ;;

		git)	
		local name=${fname%*.git}
		cd ${YPPATH_SOURCE}
		cd $name 2>/dev/null && git pull || git clone ${1} 
		[ "$?" == "0" ] && return 0 ;;

    http|https|ftp|*)	
		local checksum_server="$checksum"

		# target is exists and checksum_server is empty or checksum correct
		if [ -f "$target" ]; then
			if [ "x$checksum_server" = "x" ]; then
				msg ">>> $target exists without checksum." 
				return 0
			fi
			
			for checktool in $CHECK_TOOLS; do
				checksum_local=($($checktool "$target" 2>/dev/null))
				checksum_local="${checksum_local[0]}"
				if [ "x$checksum_local" = "x$checksum_server" ]; then
					msg ">>> $target exists and $checktool checked correctly." 
					return 0
				fi
			done

			local checkok="not"

		fi

		# target is not exists or checksum fail 
		if [ -f "$target" ] || [ "x$checkok" != "xyes" ]; then
			rm -f "$target".tmp 2>/dev/null

			if do_download $uri $fname; then
				download="done"
			else
				# Try ylmfos dist source
				uri="$YPPATH_DIST_URI/${fname}"
				do_download $uri $fname && download="done" || download="error"
			fi

			if [ "x$download" = "xdone" ]; then
				# Check again
				for checktool in $CHECK_TOOLS; do
					checksum_local=($($checktool "$target".tmp 2>/dev/null))
					checksum_local="${checksum_local[0]}"
					if [ "x$checksum_local" = "x$checksum_server" ] || [ "x$checksum_server" = "x" ]; then
						gmsg ">>> Rename: $target"
						gmsg ">>> $checktool: $checksum_local"
						checkok="yes"
						mv "$target".tmp "$target" 
						return 0
					else
						checkok="not"
						continue	

					fi
				done

				if [ "x$checkok" != "x$yes" ] ;then
					rmsg ">>> "$target".tmp download successfully but $checktool checked failed."				
				        return 1
				fi
			fi
		fi
	esac

	return 1
}

#
# $1 - strings
# $2 - all/name
# resules:
# ALL_PBSFILE : all version pbs files with full path 
# $NEWEST: newest or specifid version pbs files with full path
# 
ypkg_getpbsfile() {
	NEWEST=""	
	local files_ready
	local files_ready_raw
	local string="$1"
	local range="$2"
	local min
	local max
	local iname
	
	atom_parse "$1"
	local find_dir="${PBSDIR}"
	[ "x$find_dir" = "x" ] && find_dir=$YPPATH_LIB	

	if [ "x$N" == "x" ]; then
		echo "No package specified."
		return 1
	fi

	local count=0
	if [ "x$find_dir" = "x$YPPATH_LIB" ]; then
		local dir=$(find $find_dir/$T -maxdepth 2 -type d -iname "$N")
		for pack in $dir; do let "count++"; done
		
		if [ "$count"0 -gt 10 ]; then
			rmsg "Too more results: "
		        echo $dir
		        return 1
		fi
	fi

	VR="$(echo $VR |tr -d '()')"
	
	case $range in
		all)   iname="*${N}*.pbs" ;;
	       name|*) iname="${N}_*.pbs"
	esac

	local pbsfiles=($(find $find_dir/"$T" -maxdepth 3 -type f -iname "$iname"))
	
	if [ "x$pbsfiles" = "x" ]; then
		# Fixme!
		# find provide
		pbsfiles=($(find $find_dir/"$T" -maxdepth 3 -type f -iname "*.pbs" |xargs grep PROVIDE  |grep -w "$N" |awk -F: '{print $1}'))
	fi	

	[ "x$pbsfiles" = "x" ] && return 1

	case $range in
		all)  ALL_PBSFILE="${pbsfiles[@]}"
		      return 0 ;;
		name) ALL_PBSFILE="${pbsfiles[@]}"
	esac

	case x$VR in
		x\>[[:digit:]]*)	
        		min=${VR#>} 
			for file in ${pbsfiles[@]}; do
	        		atom_cmp $min $file
				[ $? -eq 2 ] && files_ready+="$file "
			done	;;

		x\>\=[[:digit:]]*) 
        		min=${VR#>=} 
			for file in ${pbsfiles[@]}; do
	        		atom_cmp $min $file
				[ $? -ne 1 ] && files_ready+="$file "
			done	;;
			
		x\<[[:digit:]]*)	 
			max=${VR#<}
			for file in ${pbsfiles[@]}; do
				atom_cmp $max $file
				[ $? -eq 1 ] && files_ready+="$file "
			done ;;

		x\<\=[[:digit:]]*)
			max=${VR#<=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $max $file
				[ $? -ne 2 ] && files_ready+="$file "
			done ;;

		x\!\=[[:digit:]]*) 
			min=${VR#!=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				[ $? -ne 0 ] && files_ready+="$file "
			done ;;

		x\=[[:digit:]]*)	
		        min=${VR#=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				[ $? -eq 0 ] && files_ready+="$file "
			done	;;

			*)
			min=${VR}	
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				if [ $? -eq 0 ]; then
					NEWEST="$file"
					return 0
				else	
					files_ready+="$file "
				fi
			done
	esac


	[ "x$files_ready" = "x" ] && return 1 || files_ready=($files_ready)

	for file in ${files_ready[@]}; do
		blank_funcs pbs
		. $file
		case $REPO in
			[Tt]esting)  
		  [ "x$ACCEPT_REPO" = "xtesting" ] && files_ready_raw+="$file " || continue  ;;
		         *)
		  files_ready_raw+="$file "
		esac
	done

	files_ready_raw=($files_ready_raw)
	NEWEST=${files_ready_raw[0]}	

	for file in ${files_ready_raw[@]}; do
		atom_cmp $file $NEWEST
		[ "$?" == "1" ] && NEWEST=$file
	done
	
	if [ "x$NEWEST" != "x" ]; then
		atom_parse $NEWEST
		return 0
	fi

	return 1
}

#
# $1 - pbsfile with full path, as is NEWEST
ypkg_begin_download() {
	local url
	local pbsfile="$1"

	ymsg ">> $T/${N}_$V$R begin download."

	blank_funcs pbs

	config="$YPINST_PREFIX "
	config="--prefix=/usr
		--sysconfdir=/etc
		--libdir=/usr/lib
		--localstatedir=/var
		--infodir=/usr/share/info
		--mandir=/usr/share/man
		--enable-shared "
		#--disable-static

	YPPATH_SCRIPT="$YPPATH_LIB/$T/$N"

	if [ -f "$pbsfile" ];then
		. $pbsfile
		err_check "* [Error]: $pbsfile is invalid! "
	else
		err_check "* [Error]: $1pbsfile not found"
	fi

	mkdir -p $YPPATH_SOURCE
	err_check "* [Error]: Create dir $YPPATH_SOURCE failed."

	# download all files
	if [ "x${SRC_URI}" != "x" ]; then
		local count=0
		local checksum=""

		# CHECKSUM: $SRC_URI in pbs file has md5sum/sha1sum/sha256sum value one by one.
		checksum=($CHECKSUM)
		
		for url in ${SRC_URI}; do
			# url localfile checksum
			check_and_download_raw $url $(basename $url) ${checksum[$count]}
			err_check "* [Error]: Download $url failed."
			let count=count+1
		done
	fi

	return 0
}

#
#
ypkg_download() {
	local string="$1"
	ypkg_getpbsfile "$string"

	if [ "$?" == "0" ]; then
		# found, download it
		ypkg_begin_download $NEWEST
		return 0
	fi

	rmsg "* [Error]: $string not found."
	return 1
}


#
# Strip unnessesary i18n in path $1
ypkg_strip_i18n() {
	local ipath="$1/usr/share/locale"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns; do
		name=${i##*/}
		str_isIn "$YP_I18N" $name 
		if [ "$?" == "1" ]; then
			# not in YP_I18N, remove.
			# msg ">>> strip i18n $name.."
			rm -rf $ipath/$name
		fi
	done
}

#
# strip unnessesary i18n in man path.
ypkg_strip_mani18n() {
	local ipath="$1/usr/share/man"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns; do
		name=${i##*/}

		# skip man1 -- man9
		str_isIn "$name" "man"
		if [ "$?" == "1" ]; then
			continue
		fi

		str_isIn "$YP_I18N" $name 
		if [ "$?" == "1" ]; then
			# not in YP_I18N, remove.
			# msg ">>> strip man-i18n $name.."
			rm -rf $ipath/$name
		fi
	done
}

#
# Upx for compressing eXecutables files
ypkg_upx_bin () {
	local dir="$1"
	find "$dir"/{,usr/}{bin,sbin} -type f -executable 2>/dev/null |while read file; do
		if ! upx -9 $file >/dev/null 2>&1; then
			[ -f $file.upx ] && rm -rf $file.upx
		fi
	done
}

#
# Strip binary in directory $1
ypkg_strip_bin() {
	local dir="$1"
	#find "$dir"/{,usr/}{bin,sbin} -type f -exec strip --strip-all '{}' ';' 2>/dev/null
	#find "$dir"/{,usr/}{lib,local/lib} -type f -exec strip --strip-debug '{}' ';' 2>/dev/null
	find "$dir" |xargs file |grep "executable" |grep ELF |cut -f 1 -d : |xargs strip --strip-unneeded 2> /dev/null
	find "$dir" |xargs file |grep "shared object" |grep ELF |cut -f 1 -d : |xargs strip --strip-unneeded 2> /dev/null
}

#
# Compress man doc and info 
ypkg_gzip_extra() {
	local dir="$1"
	rm "$dir"/usr/share/info/dir 2>/dev/null
	find "$dir"/usr/{,share/}{man,doc,info} -type f -exec gzip -9 '{}' ';' 2>/dev/null
}

# System Xorg Desktop Utilities Network Games Graphics Video             
# Audio Office Development Security Science-education Drivers
# Multimedia Misc Non-free
#
ypkg_get_category() {
	local type  category
	type=$1
	case ${type%%-*} in
 	 #	 sys)	category="System"		;;
	 #       x11)    category="Xorg"		;;
#gnome|kde|lxde|xfce)    category="Desktop"		;;
		#app)	category="Utilities"		;;
sys|x11|gnome|kde|lxde|xfce|app)
		        category="Utilities"            ;;
       www|net|mail)	category="Network"		;;
       		 im)    category="IM"		        ;;
    	      games)	category="Games" 		;;
    	   graphics)	category="Graphics" 		;;
    	      media)	category="Multimedia" 		;;
     printer|office)	category="Office" 		;;
    	        dev)	category="Development" 		;;
    	   security)	category="Security" 		;;
	    drivers)    category="Drivers"		;;
      education|sci)	category="Science-education"    ;;
		non)	category="Non-free"		;;
    	       misc)	category="Misc"                 ;;
    	          *)	category="Misc"                 ;;
	esac
	echo $category
}

#
split_dev() {
	local dir="$1"
	local destdir="$workdir"
	
	#/usr/include/ /usr/share/*/include /usr/lib/*/include
	ls -1d $dir/usr/share/*/include $dir/usr/lib/*/include \
	       $dir/usr/include 2>/dev/null |while read line; do
	        	local tmp=${line##$dir}
			local tmp=${tmp%%/include}
			domv $line $destdir/$N-dev_$V$R/$tmp
 		done
	
	#*.la *.a *.h
	devlib=$(find $dir/ -name "*.la" -o -name "*.a" 2>/dev/null)
	devlib+=" $(find $dir/ -name "*.h" 2>/dev/null)"
	if [ x"$devlib" != "x" ]; then
		for lib in $devlib; do
			i=${lib#$dir}
			libdir=${i%/*}
			domv $lib  $destdir/$N-dev_$V$R/$libdir
		done
	fi

	#pkgconfig
	pcdir=$(find $dir -type d -name "pkgconfig" 2>/dev/null)
	if [ x"$pcdir" != "x" ]; then
		for pc in $pcdir; do
			i=${pc#$dir}
			dirpc=${i%/*}
			domv $pc $destdir/$N-dev_$V$R/$dirpc
		done
	fi
	
	#/usr/share/aclocal/ogg.m4
	acl=$(ls -d $dir/usr/share/aclocal/* 2>/dev/null)
	if [ x"$acl" != "x" ]; then
		domv $dir/usr/share/aclocal $destdir/$N-dev_$V$R/usr/share
	fi
	[ -d $destdir/$N-dev_$V$R ] && echo $destdir/$N-dev_$V$R && return 0
	
	return 1
}

#
split_doc() {
	local dir="$1"
	local destdir="$workdir"
	docs=$(ls -d $dir/usr/share/doc/* 2>/dev/null)
	
	#info=$(ls -d $dir/usr/share/info/* 2>/dev/null)
	gtk_docs=$(ls -d $dir/usr/share/gtk-doc/html/* 2>/dev/null)
	if [ x"$docs" != "x" ]; then
		domv $dir/usr/share/doc $destdir/$N-doc_$V$R/usr/share
	fi
	
	#if [ x"$info" != "x" ]; then
	#	domv $dir/usr/share/info $destdir/$N-doc_$V$R/usr/share
	#fi
	if [ x"$gtk_docs" != "x" ]; then
		domv $dir/usr/share/gtk-doc/html $destdir/$N-doc_$V$R/usr/share/gtk-doc
	fi
	
	#ypkg_gzip_info $destdir/$N-doc_$V$R
	[ -d $destdir/$N-doc_$V$R ] && echo $destdir/$N-doc_$V$R && return 0
	return 1
}


#
split_i18n() {
	local dir="$1"
	local localdir="usr/share/locale"
	if ls -d $dir/$localdir/* >/dev/null 2>/dev/null; then
		ls -d $dir/$localdir/* |while read line;do
			lang=${line##*/}
			domv $dir/$localdir/$lang      $workdir/$N-i18n-${lang}_$V$R/$localdir
			echo $workdir/$N-i18n-${lang}_$V$R
		done
		return 0
	fi
	return 1
}

#
find_desktop() {
	local source_dir=$1
	file_is_exist "$source_dir/usr/share/applications/$N-gtk.desktop" && desktop="$source_dir/usr/share/applications/$N-gtk.desktop"
	file_is_exist "$source_dir/usr/share/applications/$N-[[:digit:]].desktop" && desktop="$(ls $source_dir/usr/share/applications/$N-[[:digit:]].desktop)"
	file_is_exist "$source_dir/usr/share/applications/$N.desktop" && desktop="$source_dir/usr/share/applications/$N.desktop"
	if [ "x$DESKTOPFILE" != "x" ]; then
		file_is_exist "$source_dir/$DESKTOPFILE" && desktop="$source_dir/$DESKTOPFILE"
		file_is_exist "$source_dir/usr/share/applications/$DESKTOPFILE" && desktop="$source_dir/usr/share/applications/$DESKTOPFILE"
	fi
	if [ "x$desktop" != "x" ] && file_is_exist "$desktop"; then
		echo "$desktop"
		return 0
	fi
	return 1
}

#
find_icon() {
	local desktop=$1 
	local source_dir=$2
	icon_name="$(grep ^Icon= $desktop |sed -e 's/Icon=//g')"
	if file_is_exist "$source_dir/$icon_name"; then
		icon="$source_dir/$icon_name"
	else
		file_is_exist "$source_dir/usr/share/icons/hicolor/scalable/apps/$icon_name.svg" && \
		icon="$source_dir/usr/share/icons/hicolor/scalable/apps/$icon_name.svg"
		icon_name=${icon_name%.svg}
		icon_name=${icon_name%.png}
		icon_name=${icon_name%.xpm}
		icon_name=${icon_name%.jpg}
		for i in 24x24 22x22 32x32 48x48; do
			icon="$source_dir/usr/share/icons/hicolor/"$i"/apps/$icon_name.png"
			file_is_exist "$icon" && break || continue
		done
	fi
	file_is_exist "$source_dir/usr/share/icons/$icon_name.png" && icon="$source_dir/usr/share/icons/$icon_name.png"
	file_is_exist "$source_dir/usr/share/icons/$icon_name.xpm" && icon="$source_dir/usr/share/icons/$icon_name.xpm"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.svg" && icon="$source_dir/usr/share/pixmaps/$icon_name.svg"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.xpm" && icon="$source_dir/usr/share/pixmaps/$icon_name.xpm"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.png" && icon="$source_dir/usr/share/pixmaps/$icon_name.png"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name" && icon="$source_dir/usr/share/pixmaps/$icon_name"
	if [ "x$ICONFILE" != "x" ]; then
		file_is_exist "$source_dir/$ICONFILE" && icon="$source_dir/$ICONFILE"
		file_is_exist "$source_dir/usr/share/pixmaps/$ICONFILE" && icon="$source_dir/usr/share/pixmaps/$ICONFILE"
	fi
	if [ "x$icon" != "x" ] && file_is_exist "$icon"; then
		echo "$icon"
		return 0
	fi
	return 1
}

#
# $1 - source_dir
mkpackage() {
	local sha
	local pbsfile
	local atom
	local source_dir="$1"  
	atom_parse $source_dir
	local dbdir="${YPPATH_DB#/}/$N"
	
	# Creat pkgdate
	cd $source_dir
	
	find |sort -r |fileinfo > $workdir/${N}_$V$R.list

	if [ "x$N" = "x$NN-dev" ]; then
		RDEPEND=
		BDEPEND=
		RECOMMENDED=
		PRIORITY=
		INSTALL=
		CONFLICT=
		DESCRIPTION="$DESCRIPTION (development files)" 
	else
		install=$INSTALL
		
		if [ "x$install" != "x" ] && file_is_exist "$filesdir"/$install; then
			docp "$filesdir"/$install $dbdir
		fi
	fi
	
	build_date="$(date +%s)"
	declare -a install_size=($(du $source_dir -sb))
	install_size=${install_size[0]}
	
	#creat pkginfo
	#
	cd ..

	pkgdir="${N}_$V$R-pkginfo"
	mkdir -p $pkgdir

	category=$(ypkg_get_category "$TT")
	name=$N
	version=$V$R
	yversion="$YVERSION"
	priority=$PRIORITY
	[ x"$REPO" = x ] && REPO="stable"
	repo=$REPO
	subdir="$(echo $N |cut -b1)"
	uri="$subdir/${N}_$V$R-$YARCH.$PACK_SUFFIX"
	license="$(echo $LICENSE |tr -d '<>')"
	packager="$(echo $PACKAGER |tr -d '<>')"
	homepage="$(echo $HOMEPAGE |tr -d '<>')"
	install="$INSTALL"
	arch="$YARCH"
	depend=$(echo $RDEPEND |xargs |tr " " ",")
	bdepend=$(echo $BDEPEND |xargs |tr " " ",")
	redepend=$(echo $RECOMMENDED |xargs |tr " " ",")
	conflict=$(echo $CONFLICT |xargs |tr " " ",")
	description=$(echo $DESCRIPTION |sed 's/&/and/g' |tr -d '<>')

	cd $source_dir
	find . |$CPIO --quiet -o -H newc |$XZ -7 >../$pkgdata
	size=($(du ../$pkgdata -sb))
	size=${size[0]}
	
	cd ..
	desktop=
	icon_name=
	icon=
	gname=
	gdescription=
	
	# desktop and icon
	desktop=$(find_desktop $source_dir)

	if [ "x$desktop" != "x" ] && file_is_exist "$desktop"; then
		cp $desktop  $pkgdir/$N.desktop
		cp $desktop  /usr/share/app-info/desktop/$N.desktop
		icon=$(find_icon $desktop $source_dir)
		if [ "x$icon" != "x" ] && file_is_exist "$icon"; then		
			cp $icon  $pkgdir/
			cp $icon  /usr/share/app-info/icon/
		fi
		gname="genericname type=\"desktop\""
		gdescription="description type=\"desktop\""
	else
		gname="genericname"
		gdescription="description"
	fi

	data_count="1"
	
	cat >$pkgdir/$control <<OOO
<?xml version="1.0" encoding="UTF-8"?>
<PackageInfo>
 <Package name="$name">
   <$gname>
     <keyword lang="en">$name</keyword>
   </genericname>
   <category>$category</category>           
   <arch>$arch</arch>                                        
   <version>$version</version>                            
   <yversion>$yversion</yversion>                            
   <priority>$priority</priority>                    
   <license>$license</license>
   <packager>$packager</packager>
   <homepage>$homepage</homepage>
   <repo>$repo</repo>
   <install>$install</install>
   <build_date>$build_date</build_date>    
   <uri>$uri</uri>
   <$gdescription>
     <keyword lang="en">$description</keyword>
   </description> 
   <data_count>$data_count</data_count>
   <data id="0">                                                     
     <name>pkgdata</name>                           
     <format>xz</format> 
     <size>$size</size>
     <install_size>$install_size</install_size>        
     <depend>$depend</depend>              
     <bdepend>$bdepend</bdepend>
     <recommended>$redepend</recommended>      
     <conflict>$conflict</conflict>      
   </data>                               
 </Package>
</PackageInfo>
OOO
	cd $pkgdir
	cp $workdir/${N}_$V$R.list $filelist
	
	if [ "x$install" != "x" ] && file_is_exist $filesdir/$install; then
		cp $YPPATH_SCRIPT/files/$install .
	fi
	
	tar cjf ../$pkginfo *

	# Creat ypkg package
	cd ..
	
	if [ "x$2" != "x" ]; then
		target="$2"
		tar cjf $target $pkgdata $pkginfo && echo $target
	else
		mkdir -p $YPPATH_PACKAGE/$subdir
		tar cjf $YPPATH_PACKAGE/$uri $pkgdata $pkginfo && echo $YPPATH_PACKAGE/$uri
		# update YPPATH_LOCAL_UNI
		mkdir -p ${YPPATH_LOCAL_UNI%/*}
		touch $YPPATH_LOCAL_UNI
		timeout=10

		while true; do
			[ $timeout -eq 0 ] && rm -f "$UNI_LOCKFILE"
			if ! file_is_exist "$UNI_LOCKFILE"; then
				touch $UNI_LOCKFILE
				sed -i '/# '"$N $V $R"'/d'                                 $YPPATH_LOCAL_UNI
				ypkg_find_info			                           $YPPATH_LOCAL_UNI  "remove"
				declare -a size=($(du $YPPATH_PACKAGE/$uri -sb))
				size=${size[0]}
				declare -a sha=($(sha1sum $YPPATH_PACKAGE/$uri))
				sha=${sha[0]}
				sed -i '/build_date/i\   <size>'"$size"'</size>'            $pkgdir/$control
				sed -i '/build_date/i\   <sha>'"$sha"'</sha>'               $pkgdir/$control
				echo "# $N $V $R"				  	    >>$YPPATH_LOCAL_UNI
				sed -n '/PackageInfo/,/PackageInfo/p' $pkgdir/$control |sed -e '1d' -e '$d' >>$YPPATH_LOCAL_UNI
				rm -f $UNI_LOCKFILE
				break
			else
				rmsg "* $YPPATH_LOCAL_UNI is locked, wait."
				sleep 1
				((timeout--))
			fi
		done		
	fi
}

# Check /dirs permission
check_perm_dirs () {
	local dir="$1"
	for i in tmp root proc sys; do	
		[ -d $dir/${i} ] && rm -rf $dir/${i}
	done

	for i in bin boot dev etc home lib media mnt opt sbin usr var; do
		if [ -d $dir/${i} ];then
			chown root:root $dir/${i}
			chmod 755       $dir/${i}
		fi
	done

	chmod +r /usr/share/applications/*.desktop 2>/dev/null
}

#
# $1- destdir
# 
ypkg_mkpackage() {
	[ ! -d $destdir ] && return 0

	# Source packages
	local spacks="$1 "
	NN="$N"

	#check /dirs permission
	check_perm_dirs "$destdir"

	if [ "x$YP_I18N" != "x" ];then
		#strip i18n 
		ypkg_strip_i18n $destdir
			
		#strip unnessesary i18n in man path.
		ypkg_strip_mani18n $destdir
	fi

	# Strip bin
	if ! str_isIn "$OPTIONS" "nostrip"; then
		ypkg_strip_bin $destdir
	fi

	# Upx executables files
	if str_isIn "$OPTIONS" "upx"; then
		ypkg_upx_bin $destdir
	fi

	# Split i18n
	#spacks+="$(split_i18n $destdir) "

	# Split dev
	if ! str_isIn "$OPTIONS" "nodev"; then
		spacks+="$(split_dev $destdir) "
	fi

	# Split_doc
	#spacks+="$(split_doc $destdir) "

	# Compress man doc info
	ypkg_gzip_extra $destdir

	# Mkpackges one by one
	for pack in $spacks; do
		# skip empty dirs
		local files=$(find $pack -type f)
		[ "x$files" = "x" ] && continue
		mkpackage "$pack"
	done
	return 0
}

#
ypkg_rm_packgeinfo() {
	local destpath="$YPPATH_DB"
	# Delete info files
	for i in config.gz para list pbs date size; do
		if file_is_exist "$destpath/${N}/${N}_$V$R.${i}"; then
			printf "<< file: %s\n" "$destpath/${N}/${N}_$V$R.${i}"
			rm -fr "$destpath/${N}/${N}_$V$R.${i}"
		fi
	done
	# Delete install file
	ls -1 $destpath/${N}/${N}_*.desc |while read i; do
		. ${i}
		install=$INSTALL
		if ! grep -wq INSTALL=\"$install\" $(ls -1 $destpath/${N}/${N}_*.desc |grep -v ${i}); then
			if [ -f "$destpath/${N}/$install" ]; then
				printf "<< file: %s\n" "$destpath/${N}/$install"
				rm -fr "$destpath/${N}/$install"
			fi
		fi
	done
	# Delete desc file
	printf "<< file: %s\n" "$destpath/${N}/${N}_$V$R.desc"
	rm -fr "$destpath/${N}/${N}_$V$R.desc"
	# Remove directory
	ypkg_rm_dir_safe $YPPATH_DB/$N
}


#
# find_pkg_info
# i.e.:
# 1. ypkg_find_info /var/ypkg/pbslib/universe 
# 2. ypkg_find_info /var/ypkg/pbslib/universe remove
# 3. ypkg_find_info /var/ypkg/pbslib/universe all
ypkg_find_info() {
	local file
	local first
	local last
	local action
	local tempfile=$(mktemp)
	[ "x$*" = "x" ] && return 1
	action="$2"
	file="$1"
	version=$V$R
	name=$N
	if [ "x$2" = "xall" ]; then
		version=
	fi
	ends="$(grep -n \<\/Package\> $file |awk -F: '{print $1}' |xargs)"
	if grep -q name=\"$name\"  $file; then
		grep -n name=\"$name\"  $file |awk -F: '{print $1}' |while read start ;do
			for end in $ends; do
				[ $end -gt $start ] && break ||continue
			done
		        sed -n ''"$start"','"$end"'p'  $file >$tempfile
			case $action in
			remove)
				#be care of <PackageInfo></PackageInfo>
				#start_sub=$(($start-1))
				#end_add=$(($end+1))
				if [ x"$version" != x ];then	
					if grep -q $version $tempfile && grep -q ${name}_$version $tempfile ; then
						#sed -i -e ''"$start"','"$end"'d' -e ''"$start_sub"'d' -e ''"$end_add"'d'  $file
						sed -i ''"$start"','"$end"'d' $file
					fi
				else
					sed -i ''"$start"','"$end"'d' $file
				fi
				;;
			*)
				if [ x"$version" != x ];then	
					if grep -q $version $tempfile && grep -q ${name}_$version $tempfile; then
						sed -n ''"$start"','"$end"'p' $file 
					fi
				else
					sed -n ''"$start"','"$end"'p' $file
				fi
			esac
				
		done
		rm -f $tempfile 2>/dev/null
	else
		return 1
	fi
}

# Cp desktop file to "$destdir"/usr/share/applications
dodesktop() {
	local dfile="$1"
	local picture="$2"
	local icon=""
	file_is_exist "$filesdir/${dfile##*/}"   && dfile="$filesdir/${dfile##*/}"
	file_is_exist "$filesdir/${picture##*/}" && picture="$filesdir/${picture##*/}"
	if [ x"$dfile" != x ] && file_is_exist "$dfile"; then
		mkdir -p "$destdir"/usr/share/applications
		install -m755 "$dfile" "$destdir"/usr/share/applications 
	fi
	if [ x"$picture" != x ] && file_is_exist "$picture"; then 
		docp "$picture"   "$destdir"/usr/share/pixmaps
	fi
	dfile="${dfile##*/}"
	picture="${picture##*/}"
	icon=$(grep ^Icon= "$destdir"/usr/share/applications/"$dfile" |sed 's/Icon=//g')
	name=${icon%.*}
	type=${picture##*.}
	if [ x"$type" != x ] && [ x"$picture" != x"$name.$type" ]; then 
		mv "$destdir"/usr/share/pixmaps/"$picture" "$destdir"/usr/share/pixmaps/"$name"."$type" 
	else
		return 0
	fi
}

# Add unit for systemd
dounit() {
	local file="$@"
	if [ x"$file" != x ]; then
		for i in $@; do
			if file_is_exist "$i"; then
				docp "$i" "$destdir"/lib/systemd/system
			else
				docp "$filesdir/$i"  "$destdir"/lib/systemd/system
			fi
		done
	fi
}

# Cp script to "$destdir"/etc/init.d
doinit() {
	local file="$1"
	mkdir -p "$destdir"/etc/init.d
	if [ x"$file" != x ]; then
		if file_is_exist "$file"; then
       			install -m755 "$file" "$destdir"/etc/init.d
		else
       			install -m755 "$filesdir/$file" "$destdir"/etc/init.d
		fi
	fi
}

#
# Kernel modules make/mkinstall automatically
# 
ykms() {
	# $1 action: build delete
	# $2 name
	# $3 version
	# e.g: /usr/src/rtl8101_1.020.00
	# name=rtl8101
	# version=1.020.00
	
	local show_usage=
	[ "x$1" = "x" ] && show_usage=yes
	case "$1" in 
		 install|remove|autoinstall) : ;;
		 *)	show_usage=yes
	esac
	
	if [ "x$show_usage" = "xyes" ]; then
		 msg "Usage: "
			msg "ykms build name version"
			msg "ykms install name version"
			msg "ykms remove name version"
			msg "ykms autoinstall"
			return 0
	fi

	local action="$1"
	local name="$2"
	local version="$3"
	local args="$4 $5 $6"
	local dir="$YPKPATH/modules"
	local source_dir="/usr/src/"${name}_$version""

	if [ "x$action" != "xautoinstall" ]; then
		if [ ! -d $source_dir ]; then
			rmsg "* $source_dir: not such directory"
			return 1
		fi
	fi

	#
	case "$action" in 
	install)
		cd $source_dir
		local    preparelog="$PWD/prepare-log"
		local       makelog="$PWD/make-log"
		local  mkinstalllog="$PWD/mkinstall-log"
		local  post_instlog="$PWD/post_inst-log"

		[ -f ./ykms.conf ] && . ./ykms.conf

		#if [ "x$patches" != "x" ]; then
		#	msg "* ${name}_$version kernel modules patching." 
		#	for patch in $patches; do
		#		dopatch "$patch"
		#	done
		#
		#fi

		if [ "x$prepare" != "x" ]; then
			msg "* ${name}_$version kernel modules preparing." 
        	        if ! eval $prepare >$preparelog 2>&1; then 
				rmsg "* [Error]: prepare kernel modules failed!"
			        rmsg "* prepare log: $preparelog"
		                return 1
			fi
		fi   

		msg "* ${name}_$version kernel modules compiling."
		if ! make $MAKEOPTS $make_args >$makelog 2>&1; then
			rmsg "* [Error]: build kernel modules failed!"
			rmsg "* build log: $makelog"
			return 1
		fi	

		msg "* ${name}_$version kernel modules installing."
		if [ "x$mkinstall_args" = "x" ]; then
			command="make $MAKEOPTS install"
		else
			command="make $MAKEOPTS $mkinstall_args"
		fi
		if ! eval "$command" >$mkinstalllog 2>&1; then
			rmsg "* [Error]: install kernel modules failed!"
			rmsg "* install log: $mkinstalllog"
			return 1
		fi
		
		#
		local record="$dir"/"$name"/"$version"/"$(uname -m)"/"$(uname -r)"
		mkdir -p $record
		>$record/modules
		find . -type f -name "*.ko" |sort -u |while read i; do
			local origin="$i"
			local name=${i##.*/}
			local target="$(find /lib/modules/"$(uname -r)" -type f -name ${i##*/} |head -n1)"
			if diff $origin $target >/dev/null 2>&1; then	
				msg "$name -> $target"
				sha1sum $target |while read sha1 name; do 
					echo $name $sha1 >>$record/modules
				done
			fi
		done 
		#
		make $MAKEOPTS clean >/dev/null 2>&1

		if [ "x$post_inst" != "x" ]; then
			msg "* ${name}_$version kernel modules post install." 
        	        if ! eval $post_inst >$post_instlog 2>&1; then 
				rmsg "* [Error]: post install kernel modules failed!"
			        rmsg "* post_inst log: $post_instlog"
		                return 1
			fi
		fi   

		#

		rm -rf $makepipe $makelog $mkinstallpipe $mkinstalllog $preparelog 2>/dev/null 	
		;;
	remove)
		local record="$dir"/"$name"/"$version"/"$(uname -m)"/"$(uname -r)"
		cat $record/modules |while read file sha1; do
			sha1_old=${sha1}
			#file=($(find /lib/modules/"$(uname -r)" -type f -name "${name}" -exec sha1sum {} \;))
			if [ -f $file ]; then
				file=($(sha1sum $file))
				sha1_new=${file[0]}
			fi

			if [ "x$sha1_old" = "x$sha1_new" ]; then
				msg "<< file: ${file[1]}"
				rm -f ${file[1]}
			fi
		done
		
		msg "<< file: $record/modules"
		rm -f $record/modules
		
		#if [ -d $source_dir ]; then
		#	msg "<< dir: $source_dir"
		#	rm -rf $source_dir 2>/dev/null  
		#fi

		rmdir -p $record 2>/dev/null  
		;;

	autoinstall)
		ls -d1 "$dir"/*/* 2>/dev/null |awk -F\/ '{print $5 " " $6}' |while read name version;do
			ykms install $name $version
			prepare=""
			make_args=""
			mkinstall_args=""
			post_inst=""
		done   ;;

		*)  :
	esac	

	return 0
}

# cp
docp() {
	local end=${!#}
	mkdir -p "$end"
	cp -a "$@"
}

# cp and rename
docp_rename() {
	local end=${!#}
	mkdir -p "$(dirname $end)"
	cp -a "$@"
}

# mv
domv() {
	local end=${!#}
	mkdir -p "$end"
	mv "$@"
}

# mv and rename
domv_rename() {
	local end=${!#}
	mkdir -p "$(dirname $end)"
	mv "$@"
}

# cp man to dir
doman() {
	local name num
	for i in $@; do
		name=${i%.[0-9]}
		num=${i##$name}
		num=${num##.}
		if file_is_exist "$i"; then
			docp ${i} "$destdir"/usr/share/man/man${num}/
		else
			docp "$filesdir/${i}" "$destdir"/usr/share/man/man${num}/
		fi
	done
}

# link
doln(){
	local end=${!#}
	mkdir -p "$(dirname $end)"
	#ln -sf "$1"  "$2"
	ln -sf $@
}

# font
dofont() {
	msg ">>> mkfontscale $1"
	mkfontscale "$1"
	msg ">>> mkfontdir $1"
	mkfontdir  "$1"
	msg ">>> fc-cache $1"
	fc-cache -f "$1"
}

#
doinstall_info () {
	msg ">>> install info: $@"
	[ -x /usr/bin/install-info ] || return 0
	infodir=/usr/share/info
	for i in $@; do
		install-info "$infodir"/"$i" $infodir/dir 2>/dev/null
	done	
	return 0
}

#
doremove_info () {
	msg ">>> remove info: $@"
	[ -x /usr/bin/install-info ] || return 0
	infodir=/usr/share/info
	for i in $@; do
		install-info --delete "$infodir"/"$i" $infodir/dir 2>/dev/null
	done
	return 0
}


# patch
dopatch(){
	local file=""
	local dir1=""
	local dir2=""
	local num=""
	while [ "x$1" != "x" ]; do
		file="$1"
		file_is_exist "$file" || file="$filesdir/$1"
		file_is_exist "$file" || file="$filesdir/patches/$1"
		if ! file_is_exist "$file"; then
			rmsg "* [Error]: \"$1\" not found."
			exit  1
		fi
		dir1="$(grep ^--- "$file" |head -n1 |awk '{print $2}' |awk -F/ '{print $1}' |tr -d '\r')"
		dir2="$(grep ^+++ "$file" |head -n1 |awk '{print $2}' |awk -F/ '{print $1}' |tr -d '\r')"
		if ls -d "$dir1" >/dev/null 2>/dev/null || ls -d "$dir2" >/dev/null 2>/dev/null;then
			num="0"
		else
			num="1"
		fi
		mmsg ">>> Patching ${file##*/}.."
		patch -p$num -i "$file" 
		shift
	done
}

#
dounpack() {
	if [ "x$SRC_URI" = "x" ];then
		for i in tar.bz2 tar.gz bz2 tgz tbz tbz2 rar zip 7z; do
			file_is_exist "$YPPATH_SOURCE/$N-$V$R.${i}" && SRC_URI="$YPPATH_SOURCE/$N-$V$R.${i}"
		done
	else
		file_is_exist "$SRC_URI" && SRC_URI="$SRC_URI"
		file_is_exist "$YPPATH_SOURCE/$SRC_URI" && SRC_URI="$YPPATH_SOURCE/$SRC_URI"
	fi
	[ "x$SRC_URI" = "x" ] && return 0
	SRC_URI=($SRC_URI)
	local first_pack=${SRC_URI[0]}
	local fname=$(basename $first_pack)
	case $fname in
		*.tar.*|*.gz|*.tar|*.tgz|*.tbz2|*.tbz|*.bz2)
			mmsg ">>> tar xf "$YPPATH_SOURCE"/$fname"
			name=$(tar -tf "$YPPATH_SOURCE"/"$fname" |head -n1 |awk -F/ '{print $1}')
			if [ "x$name" = "x." ]; then
				name=$(tar -tf "$YPPATH_SOURCE"/"$fname" |head -n1 |awk -F/ '{print $2}')
			fi
			if [ "x$name" != "x" ]; then
				tar xf "$YPPATH_SOURCE"/"$fname" 
			else
				[ -d "$N-$V$R" ] && rm -r "$N-$V$R"
				mkdir -p "$N-$V$R"
				tar xf "$YPPATH_SOURCE"/"$fname" -C "$N-$V$R"
			fi
			;;
		*.rar) 
			mmsg ">>> unrar xf "$YPPATH_SOURCE"/$fname"
			unrar x "$YPPATH_SOURCE"/"$fname" ;;
		*.zip)
			mmsg ">>> unzip xf "$YPPATH_SOURCE"/"$fname""
			num="$(unzip -l "$YPPATH_SOURCE"/"$fname" |awk '{print $4}' |awk -F/ '{print $1}' \
				|sort -u |sed -e '/^----$/d' -e '/^$/d' -e '/^Name$/d' |wc -l)"
			if [ $num -ne 1 ];then
				unzip "$YPPATH_SOURCE"/"$fname" -d "$N-$V$R"
				name="$N-$V$R"
			else
				name=$(unzip -l "$YPPATH_SOURCE"/"$fname" |sed -n '4p'  |awk '{print $4}')
				if [ x${name##*/} = x ];then
					unzip "$YPPATH_SOURCE"/"$fname"
					name="${name%%/*}"
				else
				        unzip "$YPPATH_SOURCE"/"$fname" -d "$N-$V$R"
				        name="$N-$V$R"
				fi      
			fi	;;
		 *.deb) 
		 	mmsg ">>> ar x "$YPPATH_SOURCE"/"$fname""
                    	name=$(ar t "$YPPATH_SOURCE"/"$fname" |grep data)
			mkdir -p "$N-$V$R" && cd "$N-$V$R"
			ar x "$YPPATH_SOURCE"/"$fname"
			mkdir -p data && cd data
			tar xf ../"$name"  
			cd ../../  && return 0	 ;;
		 *.rpm) 
		 	mmsg ">>> unpack "$YPPATH_SOURCE"/"$fname"" 
			name=${fname%.rpm}
			mkdir -p "$N-$V$R" && cd "$N-$V$R"
		 	rpm2tarbz2 "$YPPATH_SOURCE"/"$fname"
			mkdir -p data && cd data
			tar xf ../$name.tar.bz2
			cd ../../  && return 0	 ;;
		*.7z)   
			mmsg ">>> 7z x "$YPPATH_SOURCE"/$fname"
			name=$(7z l "$YPPATH_SOURCE"/$fname |grep -A2 "Size   Compressed  Name" |tail -n1 |awk '{print $6}')
			name=${name%%/*}
			7z x "$YPPATH_SOURCE"/"$fname" 
			;;
		 *.ar)  ;;
	   	    *)
		    	mmsg ">>> cp -a ${YPPATH_SOURCE}/$name $PWD/"$N-$V$R""
		        name=${fname%*.git}
		        cp -a ${YPPATH_SOURCE}/$name .
	esac
	if [ x"$name" != x"$N-$V$R" ] && [ x"$name" != x ];then
		if ls $name/* >/dev/null  2>&1;then
			[ -d "$N-$V$R" ] && rm -r "$N-$V$R"
			mv "$name" "$N-$V$R"
		else
			mkdir -p "$N-$V$R"
			mv "$name" "$N-$V$R"
		fi
	fi
}

# Configure
doconfig() {
	local command=""
	local command1=""
	local command2=""
		
	# waf
	[ -x waf ] && command="./waf configure $(echo $config |xargs)"
	if [ x"$command" != x ];then
		mmsg ">>> $command"
		$command && return 0
	fi
	
	# generic
	[ -x configure ] && command="./configure $(echo $config |xargs)"
	[ -x Configure ] && command="./Configure $(echo $config |xargs)"
	if [ x"$command" != x ];then
		mmsg ">>> $command"
		$command && return 0
	fi

	# autogen
	if [ -x autogen.sh ];then
		command="./autogen.sh" 
		command1=" ./configure $(echo $config |xargs)"
	fi
	if [ x"$command" != x ];then
		mmsg ">>> $command; $command1"
		$command
		$command1 && return 0
	fi
	
	# perl module
	file_is_exist Makefile.pl && mv Makefile.pl Makefile.PL
	file_is_exist Makefile.PL && command="perl Makefile.PL -y PREFIX=/usr $@"
	if [ x"$command" != x ];then
		mmsg ">>> $command"
		if ! eval $command; then
			command="perl Makefile.PL PREFIX=/usr $@"
			mmsg ">>> $command"  
			eval $command && return 0
		else
			return 0
		fi
	fi

	# cmake
	if file_is_exist CMakeLists.txt; then
		command="mkdir -p build"
		command1="cd build"
		command2="cmake ../ -DCMAKE_INSTALL_PREFIX=/usr" # -DCMAKE_SHARED_LIBRARY_PREFIX=lib"
		mmsg ">>> $command; $command1; $command2 $@"
		$command
		$command1
		$command2 && return 0
	fi

	# qmake
	if ls *.pro >/dev/null 2>/dev/null; then
		command="qmake $@"
		mmsg ">>> $command"
		$command && return 0
	fi

	# scons
	if file_is_exist SConstruct; then
		#command="scons --prefix=/usr"
		command="scons $(echo $config |xargs)"
		mmsg ">>> $command"
		$command 
	fi	
}

# Make
domake() {
	local command="make $MAKEOPTS $@"
	if [ -x waf ];then
		command="./waf build $MAKEOPTS $@"
		mmsg ">>> $command"
		$command && return 0
	fi
	if file_is_exist setup.py;then
		if [ "x$1"  = "xmake" ]; then
			command="make $MAKEOPTS $@"
		else
			command="python setup.py build $@"
		fi
		mmsg ">>> $command"
		$command && return 0
	fi
	if file_is_exist Makefile || file_is_exist GNUmakefile; then
		command="make $MAKEOPTS $@" 
	fi
	if file_is_exist makefile.linux; then
                command="make $MAKEOPTS -f makefile.linux $@"
	fi
	if file_is_exist Imakefile; then
		command="make $MAKEOPTS $@"
	fi
	if file_is_exist SConstruct; then
	        return 0
	fi

	mmsg ">>> $command"
	$command
}

# Make install
domkinstall() {
	local command="make DESTDIR="$destdir" "$@" install"
	if [ -x waf ];then
		command="./waf install --destdir="$destdir" $@"
		mmsg ">>> $command"
		$command && return 0
	fi
	if file_is_exist setup.py;then
		if [ "x$1"  = "xmake" ]; then
			command="make DESTDIR="$destdir" $@ install"		
		else
			command="python setup.py install --prefix=/usr --root="$destdir" $@"
		fi
		mmsg ">>> $command"
		$command && return 0
	fi
		
	if file_is_exist SConstruct;then
		if [ x"$@" = x ]; then
			command="scons --install-sandbox="$destdir" "$@" install"
		else
			command="scons "$@" install"
		fi
		mmsg ">>> $command"
		$command && return 0
	fi	

	if file_is_exist Makefile || file_is_exist GNUmakefile; then
		command="make DESTDIR="$destdir" "$@" install"
	fi	
	mmsg ">>> $command"
	$command 
	ldconfig
}

# Cp src file to specified dir
dosrc() {
	mmsg ">>> Copy source files: /usr/src/"${N}_$V$R""
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	cp -a "$@" "$destdir"/usr/src/"${N}_$V$R"/
}

# Cp supported to specified dir
dosupported() {
	mmsg ">>> Copy supported file: $1"
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	install -m755 "$filesdir/$1" "$destdir"/usr/src/"${N}_$V$R"
}

# Cp ykms.conf to specified dir
doykms() {
	mmsg ">>> Copy ykms file: ykms.conf"
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	install -m755 "$filesdir/ykms.conf" "$destdir"/usr/src/"${N}_$V$R"
}


# Cp doc to specified dir
dodoc() {
	mmsg ">>> Copy documents: $@"
	install -m755 -d "$destdir"/usr/share/doc/"$N"/
	cp -a "$@" "$destdir"/usr/share/doc/"$N"/
}

#
# Ypkg useradd
douseradd() {
	local end=${!#}
	local N=$end
	if ! getent passwd "$N" >/dev/null; then 
		msg ">>> Creating: user $N"
		useradd "$@"
	fi
}

#
# Ypkg userdel
douserdel() {
	local end=${!#}
	local N=$end
	if getent passwd "$N" >/dev/null; then 
		msg ">>> Deleting: user $N"
		userdel "$@"
	fi
}

#
# Ypkg groupadd
dogroupadd() {
	local end=${!#}
	local N=$end
	if ! getent group "$N" >/dev/null; then
		msg ">>> Creating: group $N"
		groupadd "$@"
	fi
}

#
#
# Ypkg groupdel
dogroupdel() {
	local end=${!#}
	local N=$end
	if getent group "$N" >/dev/null; then
		msg ">>> Deleting: group $N"
		groupdel "$@"
	fi
}

#
#
dolibtool_finish () {
	local dir="$@"
	msg ">>> Libtool finish: $dir"
	libtool --finish --silent $dir
}

#
perl_cleanup () {
	msg ">>> Delete: .packlist *.pod files"
	find "$destdir" -name '.packlist' -delete
	find "$destdir" -name '*.pod' -delete
}

#
glib_compile_schemas() {
	if [ -x /usr/bin/glib-compile-schemas ]; then
		msg ">>> glib-compile-schemas /usr/share/glib-2.0/schemas"
		/usr/bin/glib-compile-schemas  /usr/share/glib-2.0/schemas/
	else
		msg "* /usr/bin/glib-compile-schemas not found."
		return 1
	fi
	return 0
}

#
doinstall_catalog() {
	local bin=$(which install-catalog)
	if [ -x $bin ]; then
		$bin --add $@
	fi
}

doremove_catalog() {
	local bin=$(which install-catalog)
	if [ -x $bin ]; then
		$bin --remove $@
	fi
	
}

# Install defaut settings
gnome2_install_defaut_gconf() {
	#type
	local t=$1	
	#name
	local n=$2
	#value
	local v=$3
	msg ">>> Setting: \"$n\" \"$v\""
	if [ -x /usr/bin/gconftool-2 ]; then
		configfile=$(/usr/bin/gconftool-2 --get-default-source)
		if [ "x$t" = "xlist" ];then
			/usr/bin/gconftool-2 --direct --config-source="$configfile" --type list --set "$n" --list-type string "$v"
		else
			/usr/bin/gconftool-2 --direct --config-source="$configfile" --type "$t" --set "$n" "$v"
		fi
	fi
}

# Install schemas
gnome2_install_schema() {
	#this is this-is-deprecated
	#return 0
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/gconftool-2 ];then
		for schema in $schemas; do
			msg ">>> Installing: $schema"
			GCONF_CONFIG_SOURCE="$(gconftool-2 --get-default-source)" gconftool-2 --makefile-install-rule "$schema"  >/dev/null
		done
	fi
}

# Unstall schemas
gnome2_uninstall_schema() {
	#this is this-is-deprecated
	#return 0
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/gconftool-2 ];then
		for schema in $schemas; do
			msg ">>> Uninstalling: $schema"
			GCONF_CONFIG_SOURCE="$(gconftool-2 --get-default-source)" gconftool-2 --makefile-uninstall-rule "$schema"  >/dev/null
		done
	fi
}

# Install mine
gnome2_install_mine() {
	local mines="$@"
	if [ x"$mines" != x ] && [ -x /usr/bin/xdg-mime ];then
		for mine in $mines; do
			msg ">>> Installing: $mine"
			xdg-mime install --mode system "$mine"  >/dev/null
		done
	fi
}

# Unstall mine
gnome2_uninstall_mine() {
	local mines="$@"
	if [ x"$mines" != x ] && [ -x /usr/bin/xdg-mime ];then
		for mine in $mines; do
			msg ">>> Uninstalling: $mine"
			xdg-mime uninstall --mode system "$mine"  >/dev/null
		done
	fi
}

# Update rarian database
gnome2_rarian_sk_update() {
	if [ -x /usr/bin/rarian-sk-update ]; then
		msg ">>> Updating rarian database.."
		/usr/bin/rarian-sk-update
	fi
}

# Update desktop entries
gnome2_desktop_database_update() {
	if [ -x /usr/bin/update-desktop-database ]; then
		msg ">>> Updating desktop database.."
		/usr/bin/update-desktop-database
	fi
}

# Restart gconfd-2 if running to reload new gconf settings
gnome2_gconfd_reload() {
	if ps acx | grep -q gconfd-2; then
		msg ">>> Reloading gconfd settings.."
		killall -HUP gconfd-2
	fi
}

# Update gtk-immodules
gnome2_gtk_immodules_update() {
	if [ -x /usr/bin/update-gtk-immodules ]; then
		msg ">>> Updating gtk immodules.."
		update-gtk-immodules --verbose
        fi
}

# Update gdk pixbuf loaders
gnome2_gdk_pixbuf_loaders_update() {
	if [ -d /etc/gtk-2.0 ] && [ -x /usr/bin/update-gdk-pixbuf-loaders ]; then
		msg ">>> Updating gdk pixbuf loaders.."
		update-gdk-pixbuf-loaders
	fi
}

# Updates Gtk+ icon cache files under /usr/share/icons if the current pbs
# have installed anything under that location.
gnome2_icon_cache_update() {
	local dir=""
	#gnome2_icon_cache_update /usr/share/icons/titans|titans
	local updater="$(type -p gtk-update-icon-cache 2> /dev/null)"
	if [ "x$*" = "x" ]; then
		dir="/usr/share/icons/hicolor"
	else
		while [ "x$1" != "x" ]; do
			if [ ! -d "$1" ]; then
				dir+="/usr/share/icons/"$(basename $1)" "
			else	
				dir+="$1 "
			fi
			shift
		done
	fi
	msg ">>> Updating icons cache: $dir"
	"$updater" -f -q -t $dir
}

# Update mime database
gnome2_mime_database_update() {
	if [ -x /usr/bin/update-mime-database ]; then
		/usr/bin/update-mime-database /usr/share/mime/ 
	fi
}


# Return value
# 0 ok
# 1 invalid format or file not found
# 2 missing runtime deps
# 3 conflicting deps
# 4 2 and 3 
ypkg_check_package () {
	local pack="$(readlink -f $1)"
	local workdir="$(mktemp -d)"
	trap "rm -r $workdir; return 1" INT
	if ! file_is_exist $pack; then
		echo "* $pack not found" 1>&2
		rm -rf $workdir
		return 1
	fi
	cd $workdir
	atom_parse ${pack##*/}
	tar xf $pack $pkginfo 2>/dev/null && tar xf $pkginfo $control 2>/dev/null
	if [ "x$?" != "x0" ]; then
		echo "* $pack invalid ypk format"  1>&2
		rm -rf $workdir
		return 1
	fi
	depends=($(grep "<depend>" $control |sort -u |sed -e 's/<depend>//g' -e 's/<\/depend>//g' -e 's/,/ /g'))
	codepends=($(grep "<conflict>" $control |sort -u |sed -e 's/<conflict>//g' -e 's/<\/conflict>//g' -e 's/,/ /g'))
	missing_deps=
	for ((i=0; i<${#depends[@]}; i++)); do
		is_installed ${depends[i]} || missing_deps+="${depends[i]} "
	done
	conflict_deps=
	for ((i=0; i<${#codepends[@]}; i++)); do
		is_installed ${codepends[i]} || conflict_deps+="${codepends[i]} "
	done
	if [ "x$missing_deps" != "x" ]; then
		echo "missing deps: $missing_deps" 1>&2
		return_value="2"
	fi
	if [ "x$conflict_deps" != "x" ]; then
		echo "conflicting deps: $conflict_deps" 1>&2			
		return_value="3"
	fi
	if [ "x$missing_deps" != "x" ] && [ "x$conflict_deps" != "x" ]; then
		return_value="4"
	fi
	if [ "x$missing_deps" != "x" ] || [ "x$conflict_deps" != "x" ]; then
		rm -rf $workdir
		return $return_value
	fi

	rm -rf $workdir
}


#
install_pack () {
	local pack="$(readlink -f $1)"

	if [ "x$workdir" = "x" ]; then
		local myworkdir="$(mktemp -d)"
		workdir=$myworkdir
		trap "rm -r $workdir $WORLD_LOCKFILE 2>/dev/null; return 1" INT
	fi
	#
	cd $workdir
	
	pack_=${pack##*/}
	N=${pack_%_*}
	if ! tar xf $pack $pkginfo; then
		rmsg "* invalid ypk format. "
		[ -d $myworkdir ] && rm -rf $myworkdir
		return 1
	fi

	if ! tar xf $pkginfo $control; then
		rmsg "* invalid ypk format. "
		[ -d $myworkdir ] && rm -rf $myworkdir
		return 1
	fi
	VR="$(get_value version $control)"

	atom_parse "${N}_$VR"
	#current_name
	c_name="$N"
	#current_version
	c_version="$V$R"
	pre_install_listfile=$(ypkg_getlistfile all |tr ' ' '\n' |grep -v "${N}_$V$R".list)
	atom_parse $pre_install_listfile
	# INSTALL_VERSION
	if [ "x$V$R" != "x" ]; then
		p_version="$V$R"	
		atom_cmp ${N}_$p_version ${N}_$c_version
		case "x$?" in
			x2) operate="upgrade"   ;;
			x1) operate="downgrade" ;;
			 *) operate=""
		esac	
	fi

	#
	if tar xf $pkginfo 2>/dev/null; then
		install="$(get_value install $control)"
		if [ "x$install" != "x" ] && file_is_exist $install; then
			. $install
			case $operate in 
			upgrade|downgrade)
				if type pre_$operate >/dev/null 2>&1; then
					msg "* Call pre_$operate of ${c_name}_$c_version"
					pre_$operate $c_name $c_version $p_version
					err_check "* [Error]: ${c_name}_$c_version call pre_$operate failed"
				fi	
					;;
			     *)
				if type pre_install >/dev/null 2>&1; then
					msg "* Call pre_install of ${c_name}_$c_version"
					pre_install $c_name $c_version
					err_check "* [Error]: ${c_name}_$c_version call pre_install failed"
				fi
			esac
		fi
	fi
	tar xf $pack $pkgdata
	cd "$YPKG_ROOT" && $XZ -d -c $workdir/$pkgdata |$CPIO -idum --quiet
	err_check "* [Error]: ${N}_$V$R copy binary package to / failed"
	
	#check /dir permissions
	for i in bin dev etc home run usr var; do
		chmod 755 "$YPKG_ROOT"/"$i"
	done

	#
	if [ "x$install" != "x" ] && file_is_exist $YPPATH_DB/$c_name/$install; then
		. $YPPATH_DB/$c_name/$install
		case $operate in
		upgrade|downgrade)
			if type post_$operate >/dev/null 2>&1; then
				msg "* Call post_$operate of ${c_name}_$c_version"
				post_$operate $c_name $c_version $p_version
				err_check "* [Error]: ${c_name}_$c_version call post_$operate failed"
			fi	
				;;
			*)
			if type post_install >/dev/null 2>&1; then
				msg "* Call post_install of ${c_name}_$c_version"
				post_install $c_name $c_version
				err_check "* [Error]: ${c_name}_$c_version call post_install failed"
		fi
		esac
	fi
	
	#install time
	atom_parse ${c_name}_$c_version
	IT=$(date +%s)
	echo "INSTALL_TIME=\"$IT\""                     >>$YPPATH_DB/$N/${N}_$V$R.desc
	
	#
	cd $workdir
	cp $YPPATH_WORLD $YPPATH_WORLD-
	timeout=10
	while true; do
		[ $timeout -eq 0 ] && rm -f "$WORLD_LOCKFILE"
		if ! file_is_exist "$WORLD_LOCKFILE"; then
			touch $WORLD_LOCKFILE
			ypkg_find_info $YPPATH_WORLD remove
			sed -i '/<\/PackageInfo>/d'                      $YPPATH_WORLD
			ypkg_find_info $control 		       >>$YPPATH_WORLD
			echo "</PackageInfo>"                          >>$YPPATH_WORLD
			rm -f $WORLD_LOCKFILE
			break
		else
		        rmsg "* $YPPATH_WORLD is locked, wait."
		        sleep 1
			((timeout--))
		fi
	done

	# remove old version 
	if [ "x$p_version" != "x" ] && [ "x$p_version" != "x$c_version" ]; then
		msg "* Remove previous packages: ${c_name}_$p_version"
		ypkg_upgrade_remove "${c_name}_$p_version" "${c_name}_$c_version" "$operate"
	fi

	# remove conflict packages 
	. $YPPATH_DB/$c_name/${c_name}_$c_version.pbs 2>/dev/null
	if [ "x$CONFLICT" != "x" ]; then
		for i in $CONFLICT; do
			atom_parse $i
			if is_installed $N ; then
				atom_parse "$(ypkg_getlistfile)"
				msg "Remove conflicting packages: ${N} $V$R"
				ypkg_conflict_remove "${N}" "$V$R" "${c_name}" "$c_version"
			fi
		done
	fi
	[ -d $myworkdir ] && rm -rf $myworkdir
}

#

#
# Install package
#

#
#fetch           break after download source tarball
#upack           break after unpack source tarball
#patch           break after patch source
#config          break after configure	
#build           break after make a.k.s compile
#check		 break after make check/test
#mkinstall         break after make install    
#package         break after make ypk package    

maybe_break() {
	local string="$1"
	local command="$(echo $@ |sed 's/'"$string"'//')"
	if echo "$BREAK" | egrep -q "(,|^)$string(,|$)"; then
		$command
		exit 1
	fi
}

#
# $1 - as follows:
# pkgname - lftp
# pkgtype/pkgname -net-ftp/lftp
# pbsfile - lftp_4.3.3.pbs 
#
ypkg_install() {
	local string="$1"
	local stat

	if ! ypkg_getpbsfile "$string"; then
		rmsg "[Error]: $string not found."
		return 1
	fi

	ypkg_searchInstalled $T $N $V$R >/dev/null
	
	local new=$V$R
	
	if [ "x$INSTALL_STATUS" = "xuninstall" ]; then
		stat="N"
	else
		atom_cmp $INSTALL_VERSION $new 
		case $? in
			1) stat="D"  ;;
	 		2) stat="U"  ;;
	 		0) stat="E"
		esac
	fi

	[ "x$FORCE_INSTALL" != "xyes" ] && gmsg_ "[$stat]" || gmsg_ "["$stat"F]"

	# N -- new install
	# U -- upgrade
	# D -- downgrade
	# E -- same version
	case $stat in
        	E) msg " $T/${N}_$V$R "	
		   [ "x$FORCE_INSTALL" != "xyes" ] && return 0         ;;
		N) msg " $T/${N}_$V$R "				       ;;
   	      U|D) msg " $T/${N}_$INSTALL_VERSION ----> $T/${N}_$V$R " 
	esac
		
	[ "x$PRETEND" = "xyes" ] && return 0
	
	ypkg_begin_download $NEWEST || return 1

	maybe_break fetch 

	#
	# Download ok, install it.
	#		
	
	workdir="$YPPATH_FIELD/$N"
	mkdir -p $workdir
	trap "rm -r $workdir $UNI_LOCKFILE 2>/dev/null; exit 1" INT
	
	cd $workdir

	ymsg ">> $T/${N}_$V$R unpack"
	pbs_unpack
	err_check "* [Error]: $T/${N}_$V$R call pbs_unpack failed"

	maybe_break unpack pwd

	destdir="$workdir/${N}_$V$R"
	local pbsfile="$NEWEST"
	local pbsdir="${NEWEST%/*.pbs}"
	filesdir="${pbsdir}"/files
	buildlog="$pbsdir/${N}_$V$R-$YARCH.buildlog"

	local 	 patchpipe="$PWD/patch.pipe"
	local     patchlog="$PWD/patch-log"
	local 	 configpipe="$PWD/config.pipe"
	local     configlog="$PWD/configure-log"
	local      makepipe="$PWD/make.pipe"
	local       makelog="$PWD/make-log"
	local     checkpipe="$PWD/check.pipe"
	local      checklog="$PWD/check-log"
	local mkinstallpipe="$PWD/mkinstall.pipe"
	local  mkinstalllog="$PWD/mkinstall-log"

	cd "$N-$V$R" 2>/dev/null

	ymsg ">> $T/${N}_$V$R patch"
	[ -p $patchpipe ] || mkfifo $patchpipe
	tee $patchlog < $patchpipe & 
	pbs_patch > $patchpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_patch failed"

	maybe_break patch pwd

	ymsg ">> $T/${N}_$V$R configure"
	[ -p $configpipe ] || mkfifo $configpipe
	tee $configlog < $configpipe & 
	pbs_config > $configpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_config failed"

	maybe_break config pwd

	ymsg ">> $T/${N}_$V$R compile"
	[ -p $makepipe ] || mkfifo $makepipe
	tee $makelog < $makepipe & 
	pbs_build > $makepipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_build failed"

	maybe_break build pwd

	ymsg ">> $T/${N}_$V$R make check"
	[ -p $checkpipe ] || mkfifo $checkpipe
	tee $checklog < $checkpipe & 
	pbs_check > $checkpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_check failed"

	maybe_break check pwd

	ymsg ">> $T/${N}_$V$R make install"
	local packs=""
	local destdirs=($destdir)
	local descfiles=($descfiles)
	TT="$T"
	
	gene_desc() {
		local file=$1
        	cat >$file <<EOF
N="$N"
V="$V"
R="$R"
DESCRIPTION="$DESCRIPTION"
COMMENTS="$COMMENTS"
HOMEPAGE="$HOMEPAGE"
REPO="$REPO"
YARCH="$YARCH"
LICENSE="$LICENSE"
PRIORITY="$PRIORITY"
PACKAGER="$PACKAGER"
RDEPEND="$RDEPEND"
BDEPEND="$BDEPEND"
RECOMMENDED="$RECOMMENDED"
CONFLICT="$CONFLICT"
OPIONAL="$CONFLICT"
INSTALL="$INSTALL"
OPTIONS="$OPTIONS"
EOF
}
	gene_desc base.desc 
	descfiles[0]=$(readlink -f base.desc)
	
	[ -p $mkinstallpipe ] || mkfifo $mkinstallpipe
	tee $mkinstalllog < $mkinstallpipe & 
	pbs_install > $mkinstallpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_install failed"

	if [ "x$PROVIDE" != "x" ]; then	
		ymsg ">> $T/${N}_$V$R splite $PROVIDE."
		j=1

		for i in $PROVIDE; do
			. ${descfiles[0]}
			destdir="$workdir/${i}_$V$R"
			atom_parse $destdir
		
			ymsg ">> $TT/${N}_$V$R make install"
			${i}_install
			err_check "* [Error]: $TT/${N}_$V$R call ${N}_install failed"

			gene_desc $N.desc
			descfiles[$j]=$(readlink -f $N.desc)
			destdirs[$j]=$destdir
			blank_funcs
			let j=$j+1
		done

	fi

	>$buildlog
	[ -e $configlog ] && cat $configlog >> $buildlog
	[ -e $makelog ]   && cat $makelog >> $buildlog
	[ -e $checklog ]  && cat $checklog >> $buildlog
	[ -e $mkinstalllog ] && cat $mkinstalllog >> $buildlog
	[ -e $buildlog ]  && gzip -9 -f $buildlog

	maybe_break mkinstall pwd

	# make pkg package
	j=0
	for destdir in ${destdirs[@]}; do
		atom_parse $destdir
		ymsg ">> $TT/${N}_$V$R make package"
		. ${descfiles[$j]}
		packs+="$(ypkg_mkpackage $destdir) "
		err_check "* [Error]: $TT/${N}_$V$R make binary package failed"
		blank_funcs
		let j=$j+1
	done

	rm ${descfiles[@]}

	packs=$(echo $packs |tr ' ' '\n' |sort -u |xargs)

	maybe_break package "echo $packs"

	# install to system
	ymsg ">> $TT/${N}_$V$R $PROVIDE install to system"

	for pack in $packs; do
		case "x$AUTO_INSTALL" in
			xyes) mmsg ">>> Install: $pack"
			      #install_pack $pack ;;
			      ypkg2 -I -f $pack ;;
			   *) gmsg ">>> $pack"
		esac
	done

	[ -d $workdir ] && rm -r $workdir

	return 0
}

#
# $1 pkgname
# $2 notes/comments/depend/pbs
#
ypkg_show() {
	local ret
	local itype
	local iname
	local iver
	local irver
	ypkg_getpbsfile "$1"

	if [ $? == 0 ]; then
		atom_parse $NEWEST
		itype=$T
		iname="$N"
		iver=$V
		irver=$R
		. "$NEWEST"
		
		case $2 in
		notes)
			echo -e "$NOTES" ;;
		comments)
			echo -e "$COMMENTS" ;;
		depend)
			local pbsfile=${NEWEST##*/}
			msg_ ">> Dependencies of "
			wmsg "${pbsfile%*.pbs}:"
			gmsg "* Build_time"
			echo $BDEPEND |xargs
			gmsg "* Run_time"
			echo $RDEPEND |xargs
			gmsg "* Recommend"
			echo $RECOMMENDED |xargs
			gmsg "* Conflict"
			echo $CONFLICT |xargs ;;
		pbs)
			echo "$NEWEST"
		esac
	else
		rmsg "* [Error]: $1 not found!"
		return 1
	fi
}

#
# Operations when read a file.
# l = list files
# f = remove files/symbol links
# d = remove directorys
YP_CSV_OP="l"

ypkg_csvop_ls() {
	case "${value[0]}" in
	D)	#directory
		printf "%s| %8s| %s\n" "d" "${value[2]}" "${value[1]}"
		;;
	S)	#Link
		printf "%s| %8s| %s\n" "l" "${value[2]}" "${value[1]}"
		;;
	F)	#File
		printf "%s| %8s| %s\n" " " "${value[2]}" "${value[1]}"
		;;

	*)	#totle
		printf "\nFile: %s, Dir: %s, Link %d, Size: %dK\n" \
			"${value[1]}"\
			"${value[2]}" "${value[3]}" "${value[5]}"
		;;
	esac
	
}


#
ypkg_csvop_rm() {
	# ${value[0]} --- filetype
	# ${value[1]} --- filename
	# ${value[2]} --- size  
	# ${value[3]} --- permission
	# ${value[4]}
	# ${value[5]} 
	# ${value[6]} --- mtime
	# ${value[7]} --- md5sum
	case "${value[0]}" in
	F) #file
		file_is_exist "${value[1]}" || continue
		printf "<< file: %s\n" "${value[1]}"
		unlink "${value[1]}"    ;;
	S) #symbol.
		[ -h "${value[1]}" ] || continue
		printf "<< link: %s\n" "${value[1]}"
		unlink "${value[1]}"	;;
	D) #directory.
		[ -d "${value[1]}" ] || continue
		ypkg_rm_dir_safe "${value[1]}"
	esac
}

#
ypkg_rm_dir_safe() {
	local files
	files=$(ls "$1" 2>/dev/null)
	if [ "x$files" = "x" ]; then
		printf "<< dir: %s\n"  "$1"
		rm -rf "$1"
	fi
}

# Read from stdin
ypkg_read() {
	local line
	local count
	local -a value
	while IFS= read -r line; do
		[ -z "$line" ] && continue
		csv_split "$line"
		case "$YP_CSV_OP" in
		r)	ypkg_csvop_rm	   ;;
		l|*)	ypkg_csvop_ls	   ;;
		esac
	done
}

# Read from a file, $1 is file name, $2 is operation
ypkg_readfile() {
	YP_CSV_OP=$2
	ypkg_read < $1
}

#
ypkg_list_all_available() {
	local pbsfile line pbsdir
	local tmpfile=$(mktemp)
	find $YPPATH_LIB/*/ -maxdepth 2 -type f -name "*.pbs" |while read line;do
		. ${line}
		T=$(echo $line |awk -F/ '{print $5}')
		pbsfile=${line##*/}
		pbsdir=${line%/*}
		atom_parse $pbsfile
		if ypkg_find_info $YPPATH_UNI  >$tmpfile; then
			. $tmpfile
		else
			blank_funcs desc
		fi
		if file_is_exist "$YPPATH_DB/$N/$pbsfile"; then
			gmsg_ '[I] '  
			echo -e "$T/${N}_$V$R\t$BUILD_TIME\t$INSTALL_SIZE\t$PACK_SIZE"
		else	
			echo -e '[*]' "$T/${N}_$V$R\t$BUILD_TIME\t$INSTALL_SIZE\t$PACK_SIZE" 
		fi
		if [ x"$BRIEF" != x ];then
			echo "Description: $BRIEF"
		else
		        echo "Description: $DESCRIPTION"
		fi
		echo
	done
	rm -rf $tmpfile 2>/dev/null
}

# List installed packages
#
ypkg_list_installed() {
	local pbsfile line pbsdir
	local tmpfile=$(mktemp)
	find $YPPATH_DB/* -maxdepth 2 -type f -name "*.desc" |while read line;do
		. $line
		atom_parse $line
		gmsg_ "[I] "
		echo -e "${N}_$V$R\t$(date -d "1970-01-01 UTC $INSTALL_TIME seconds" +%F,%T 2>/dev/null)\t$INSTALL_SIZE"
		echo "Description: $DESCRIPTION"
		blank_funcs desc
	done
	rm -rf $tmpfile  2>/dev/null
}

# List all files
#
ypkg_list_showallfile() {
	local name=$1
	local version=$2
	local listfile=$(ls $YPPATH_DB/$name/${name}_$version.list 2>/dev/null)
	[ "x$listfile" = "x" ] && return 1
	ypkg_readfile "$listfile" "l"
}

# 
ypkg_list_package() {
	local ypkg_types
	local type
	local ypkg_packs
	local pack
	local findcount=0
	local pbsfile
	local i="$1"

	#get pbs file
	i=${i##*/}
	i=${i%%_[[:digit:]]*}
	listfile=$(find $YPPATH_DB/${i##*/} -maxdepth 2 -type f -name "${i##*/}_*.list" 2>/dev/null)

	if [ "x$listfile" !=  "x" ]; then
		atom_parse $listfile
	else
		rmsg "* [Error]: $1 not found." 
		return 1
	fi
	
	#
	ymsg "* Contents of ${N}_$V$R:"
	ypkg_list_showallfile $N $V$R
	ymsg "--- Contents of ${N}_$V$R ---"

	if [ $? != 0 ];then
		rmsg "* [Error]: $1 not found."
		return 1
	fi
}

#
ypkg_do_remove_package() {
	N=$1
	V=$2
	R=$3
	install=$4
	
	infofile=$YPPATH_DB/$N/${N}_$V$R.list

	#remove all files link and directories
	ypkg_readfile $infofile "r"
	
	#
	if [ "x$install" != "x" ]; then
		. $install
		if type post_remove >/dev/null 2>&1; then
			msg "* Call post_remove of ${N}_$V$R "
			post_remove $N $V$R
			err_check "* [Error]: Call post_remove of ${N}_$V$R failed"
		fi
	fi

	#remove infos.
	ypkg_rm_packgeinfo

	#remove info from word
	timeout=10
	while true; do
		[ $timeout -eq 0 ] && rm -f "$WORLD_LOCKFILE"
		if ! file_is_exist "$WORLD_LOCKFILE"; then
			touch $WORLD_LOCKFILE
			ypkg_find_info $YPPATH_WORLD  "remove"
			rm -f $WORLD_LOCKFILE
			break
		else
	        	rmsg "* $YPPATH_WORLD is locked, wait."
	        	sleep 1
			((timeout--))
		fi
	done
}

#
#
# Return specifid list files with full path
# (1) $N and $V$R != none , return $N_$V$R.list 
# (2) $V$R=none and $N != none  renturn newest version
# (3) $1=all, return all $N_.list
ypkg_getlistfile() {
	local find_dir
	local pack
	local count
	find_dir=$YPPATH_DB/$N
	declare -a count=($(ls $find_dir/${N}_*.list 2>/dev/null))
	if [ "x$1" = "xall" ]; then
		echo ${count[@]}
		return 0
	fi
	case "${#count[@]}" in
	1)	#found 1.
		if [ "x$V$R" != "x" ]; then
			ls $find_dir/${N}_$V$R.list 2>/dev/null || return 1
		else
			ls $find_dir/${N}_*.list 
		fi
		return 0	;;
	0)	#found none
		return 1	;;
	2|*)	#found 2
		if [ "x$V$R" != "x" ]; then
			ls $find_dir/${N}_$V$R.list 2>/dev/null || return 1
		else
			local max=${listfiles[0]}
			for ((i=0; i<=${#listfiles[@]}; i++)); do
				atom_cmp $max ${listfiles[i]}
				case "$?" in
				  2) max=${listfiles[i]} ;;
				  *) continue
				esac
			done
			echo $max
			return 0
		fi
	esac
	return 1
}

#
ypkg_remove_package() {
	local listfile
	local i
	local install_file=

	atom_parse "$1"
        declare -a listfile=($(ypkg_getlistfile all))
        if [ "x$listfile" != "x" ]; then
		for i in ${listfile[@]}; do
			atom_parse $i
			if file_is_exist "$YPPATH_DB/$N/${N}_$V$R.desc"; then
				blank_funcs "pbs"
				. $YPPATH_DB/$N/${N}_$V$R.desc
				install=$INSTALL
				if [ "x$install" != "x" ] && file_is_exist $YPPATH_DB/$N/$install; then
					install_file=$YPPATH_DB/$N/$install
					. $install_file
					if type pre_remove >/dev/null 2>&1; then
						msg "* Call pre_remove of ${N}_$V$R"	
						pre_remove  $N $V$R
						err_check "* [Error]: Call pre_remove of ${N}_$V$R failed"
					fi
				fi
			fi
			ymsg "* Remove content of ${N}_$V$R:"
		        ypkg_do_remove_package "$N" "$V" "$R" "$install_file"
		done
	else
	        rmsg "* [Error]: $1 not found."
		return 1
	fi

	return 0
}

#
ypkg_conflict_remove() {
	local old_name=$1
	local old_version=$2
	old_listfile="$YPPATH_DB/$old_name/${old_name}_$old_version.list"
	
	local new_name=$3
	local new_version=$4
	new_listfile="$YPPATH_DB/$new_name/${new_name}_$new_version.list"

	#
	atom_parse $old_listfile
	file_is_exist $YPPATH_DB/$N/${N}_$V$R.desc && . $YPPATH_DB/$N/${N}_$V$R.desc
	install="$INSTALL"
	if [ "x$install" != "x" ] && file_is_exist $YPPATH_DB/$N/$install; then
		. $YPPATH_DB/$N/$install
		if type pre_remove >/dev/null 2>&1; then
			msg "* Call pre_remove of ${N}_$V$R"
			pre_remove $N $V$R
			err_check "* [Error]: ${N}_$V$R call pre_remove failed"
		fi	
		INSTALL=
	fi

	#
	cat $old_listfile |while read line; do	
		csv_split "$line"
	        # ${value[0]} --- filetype
	        # ${value[1]} --- filename
		#if ! grep "^${value[0]},${value[1]}," $new_listfile >/dev/null 2>/dev/null; then
		if ! grep ",${value[1]}," $new_listfile >/dev/null 2>/dev/null; then
			case "${value[0]}" in
			F) #file
		   	   file_is_exist "${value[1]}" || continue
			   printf "<< file: %s\n" "${value[1]}"
			   unlink "${value[1]}"    ;;
			S) #symbol.
			   [ -h "${value[1]}" ] || continue
			   printf "<< link: %s\n" "${value[1]}"
			   unlink "${value[1]}"	;;
			D) #directory.
			   [ -d "${value[1]}" ] || continue
			   ypkg_rm_dir_safe "${value[1]}" 
			esac
		fi
	done
	
	#
	atom_parse $old_listfile
	file_is_exist $YPPATH_DB/$N/${N}_$V$R.desc && . $YPPATH_DB/$N/${N}_$V$R.desc
	install="$INSTALL"
	if [ "x$install" != "x" ] && file_is_exist $YPPATH_DB/$N/$install; then
		. $YPPATH_DB/$N/$install
		if type post_remove >/dev/null 2>&1; then
			msg "* Call post_remove of ${N}_$V$R"
			post_remove $N $V$R
			err_check "* [Error]: ${N}_$V$R call post_remove failed"
		fi	
		INSTALL=
	fi

	#remove infos.
	ypkg_rm_packgeinfo
        #remove info from word
	timeout=10
	while true; do
		[ $timeout -eq 0 ] && rm -f "$WORLD_LOCKFILE"
		if ! file_is_exist "$WORLD_LOCKFILE"; then
			touch $WORLD_LOCKFILE
     			ypkg_find_info $YPPATH_WORLD  "remove"
			rm -f $WORLD_LOCKFILE
			break
		else	
			rmsg "$YPPATH_WORLD is locked, wait."
			sleep 1
			((timeout--))
		fi
	done

}

#
ypkg_upgrade_remove() {
	local old="$1"
	local new="$2"
	atom_parse $old
	old_listfile=$(ypkg_getlistfile)
	atom_parse $new
	new_listfile=$(ypkg_getlistfile)
	cat $old_listfile |while read line; do	
		csv_split "$line"
	        # ${value[0]} --- filetype
	        # ${value[1]} --- filename
		#if ! grep "^${value[0]},${value[1]}," $new_listfile >/dev/null 2>/dev/null; then
		if ! grep ",${value[1]}," $new_listfile >/dev/null 2>/dev/null; then
			case "${value[0]}" in
			F) #file
		   	   file_is_exist "${value[1]}" || continue
			   printf "<< file: %s\n" "${value[1]}"
			   unlink "${value[1]}"    ;;
			S) #symbol.
			   [ -h "${value[1]}" ] || continue
			   printf "<< link: %s\n" "${value[1]}"
			   unlink "${value[1]}"	;;
			D) #directory.
			   [ -d "${value[1]}" ] || continue
			   ypkg_rm_dir_safe "${value[1]}" 
			esac
		fi
	done
	#
	atom_parse $old_listfile
	#remove infos.
	ypkg_rm_packgeinfo
        #remove info from word
	timeout=10
	while true; do
		[ $timeout -eq 0 ] && rm -f "$WORLD_LOCKFILE"
		if ! file_is_exist "$WORLD_LOCKFILE"; then
			touch $WORLD_LOCKFILE
     			ypkg_find_info $YPPATH_WORLD  "remove"
			rm -f $WORLD_LOCKFILE
			break
		else	
			rmsg "$YPPATH_WORLD is locked, wait."
			sleep 1
			((timeout--))
		fi
	done
}

#
ypkg_whatprovides() {
	local packages
	local i
	local name
	local csv
	local outcnt=0
	local count=0
	local -a value
	local file
	file="$1"
	file=$(get_abspath "$file")
	if [ ! -e "$file" ]; then
		rmsg "* $file No such file or directory."
		return 1
	fi
	findlist=$(find $YPPATH_DB -iname "*.list")
	str_isIn $file "/usr/include" && findlist=$(find $YPPATH_DB -iname "*-dev_*.list")
	packages=$(grep ",$file," $findlist)
	for i in $packages; do
		((outcnt++))
		name=${i%%:*}
		name=${name##*/}
		atom_parse $name
		csv=${i#*:}
		csv_split $csv	
		case ${value[0]} in
			S) msg "${N}_$V$R: ${value[0]},${value[1]} -> ${value[7]}" ;;
			*) msg "${N}_$V$R: ${value[0]},${value[1]}"
		esac	
	done
	if [ "$outcnt" == "0" ]; then
		echo ""
		rmsg "* $file not owned by any packages."
		echo ""
		return 1
	fi
	if [ "$outcnt" == "1" ]; then
		return 0
	fi
	return 2
}

#
#
#
ypkg_whatrequires() {
	local depend 
	local ppkg=$1
	local file
	local exits
	atom_parse $ppkg
	pkg="$N"
	exits=$(find "$YPPATH_LIB" -maxdepth 2 -type d -name "$pkg")
	if [ "x$exits" = "x" ]; then
		rmsg "* $pkg not found"
		return 1
	else
		ymsg "* "$i" is related with:"
	fi
	find "$YPPATH_DB" -maxdepth 3 -type f -name "*.pbs" |while read file; do
		atom_parse "$file"
		. "$file"
		for depend in RDEPEND BDEPEND RECOMMENDED CONFLICT; do
			if str_isIn "$(eval "echo \$${depend}")" "$pkg"; then
			#if eval "echo \$${depend}" |grep -w $pkg >/dev/null 2>&1; then
				case $depend in
				RDEPEND)
					gmsg_ "[R] "
					msg "${N}_$V$R"  ;;
				BDEPEND)
					ymsg_ "[B] "
					msg "${N}_$V$R"  ;;
			    RECOMMENDED) 
					bmsg_ "[A] "
					msg "${N}_$V$R"  ;;
			       CONFLICT)
					rmsg_ "[C] "
					rmsg "${N}_$V$R"
				esac
			fi
		done
		blank_funcs pbs
		blank_funcs desc
	done
	msg ""
}

#
ypkg_unpack_binary() {	
	local source_pack="$1"
	local target_dir="$2"
	msg ">> decompress: $source_pack"
	if tar xjpf "$source_pack" -C "$target_dir"; then
		if cd "$target_dir"; then
			msg ">> $pkginfo"
			mkdir -p "$YLMFOS"
			if tar xjpf "$pkginfo" -C "$YLMFOS"; then  
				msg ">> $pkgdata"
				"$XZ" -d -c "$pkgdata" |$CPIO -idum --quiet
			fi
		fi
	fi
	rm "$pkgdata" "$pkginfo"
}

#end of file
