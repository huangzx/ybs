
if [ "xLANG" = "x" ]; then
	export LANG="zh_CN.UTF-8"
fi

export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/opt/bin"

## -------------------- colourful print --------------------
## ANSI Foreground color codes:
## 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white 39=default
## ANSI Background color codes:
## 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white 49=default
COLOR_RED=$(    echo -e "\e[31;49m" )
COLOR_GREEN=$(  echo -e "\e[32;49m" )
COLOR_YELLO=$(  echo -e "\e[33;49m" )
COLOR_BLUE=$(   echo -e "\e[34;49m" )
COLOR_MAGENTA=$(echo -e "\e[35;49m" )
COLOR_CYAN=$(   echo -e "\e[36;49m" )
COLOR_WHILE=$(   echo -e "\033[1m" )
COLOR_RESET=$(  echo -e "\e[0m"     )
      
# Msg argv: "$str"
msg()  { echo "$@";                               }
rmsg() { echo "${COLOR_RED}$*${COLOR_RESET}";     }
gmsg() { echo "${COLOR_GREEN}$*${COLOR_RESET}";   }
ymsg() { echo "${COLOR_YELLO}$*${COLOR_RESET}";   }
bmsg() { echo "${COLOR_BLUE}$*${COLOR_RESET}";    }
mmsg() { echo "${COLOR_MAGENTA}$*${COLOR_RESET}"; }
cmsg() { echo "${COLOR_CYAN}$*${COLOR_RESET}";    }
wmsg() { echo "${COLOR_WHILE}$*${COLOR_RESET}";   }
					
# Colourful print without "\n"
msg_()  {  msg "$@" | tr -d '\n'; }
rmsg_() { rmsg "$@" | tr -d '\n'; }
gmsg_() { gmsg "$@" | tr -d '\n'; }
ymsg_() { ymsg "$@" | tr -d '\n'; }
bmsg_() { bmsg "$@" | tr -d '\n'; }
mmsg_() { mmsg "$@" | tr -d '\n'; }
cmsg_() { cmsg "$@" | tr -d '\n'; }
wmsg_() { wmsg "$@" | tr -d '\n'; }

#
# Path defines
YPPATH="/var/ybs"
YPPATH_LIB="$YPPATH/pbslib"
YPPATH_SOURCE="$YPPATH/sources"
YPPATH_SCRIPT="$YPPATH_LIB"
YPPATH_FIELD="/tmp/ybs"

YPKPATH="/var/ypkg"

YPPATH_DB="$YPKPATH/db"

#
PACK_SUFFIX="ypk"

#
CPIO="/bin/cpio"
#CPIO="/usr/bin/bsdcpio"
XZ="/usr/bin/xz"

#
CHECK_TOOLS="md5sum sha1sum sha256sum"

#
YLMFOS="YLMFOS"

#
DOWNLOAD_TOOL="wget"
WGET_OPTIONS="--tries=3 --retry-connrefused --wait=2"
DOWNLOAD_TOOL="curl"
CURL_OPTIONS="-L"

pkgdata="pkgdata"
pkginfo="pkginfo"
control="control.xml"
filelist="filelist"

#
blank_funcs () {
	DESCRIPTION=""
	COMMENTS=""
	HOMEPAGE=""
	REPO=""
	YARCH="$(uname -m)"
	LICENSE=""
	PRIORITY=""
	PACKAGER=""
	SRC_URI=""
	CHECKSUM=""
	RDEPEND=""
	BDEPEND=""
	RECOMMENDED=""
	CONFLICT=""
	NOTES=""
	OPIONAL=""
	PROVIDE=""
	INSTALL=""
	OPTIONS=""
	
	INAME=""
	CATEGORY=""
	VERSION=""
	TYPE=""
	INSTALL_SIZE=""
	BUILD_TIME=""
	BIN_URI=""
	PACK_SIZE=""
	SHA=""
	NAME=""
	if [ "x$1" = "xpbs" ];then
		pbs_unpack() { :
		}
		pbs_patch() { :
		}
		pbs_config() { : 
		}
		pbs_build() { : 
		}
		pbs_check() { : 
		}
		pbs_install() { : 
		}
	fi
	[ "x$1" = "xdesc" ] && :
}

#
#
file_is_exist () {
	[ -f "$1" ] && return 0 || return 1
}

#
# Check root
#
check_root () {
	if [ "x$UID" != "x0" ];then
	        rmsg "* You must be root to run this script."
        	ymsg "* Try: sudo $0 $*"
       		exit 1
	fi
}

#
# Smmation
# 
summation() {
	if [ "x$1" = "x" ];then
		msg "* summation: you must specify a list of digit"
		msg "* i.e. 'summation 1 2 3' "
		return 1
	fi
        local sum=0
	while [ "x$1" != "x" ]; do
		local tmp=$1
		let "sum=sum+tmp"
		shift
	done
	echo $sum
	return 0
}

#
get_abspath () {
	local file="$1"
	if [ ! -h "$file" ]; then
		 file=$(readlink -f "$file")
	else
		file=$(cd $(dirname $file) 2>/dev/null; pwd)/${file##*/}
	fi
	echo "$file"
}

#
# If $2 in $1 return 0, else return 1
#
str_isIn() {
	if [ "x$2" = "x" ];then
		msg "* str_isIn: you must specify at least two strings."
		msg "* i.e. 'str_isIn \"a b c\" b'"
		return 1
	fi
	local string=($1)
	local substring="$2"

	for i in ${string[@]}; do
		if [ "x$i" = "x$substring" ]; then
			return 0
		fi
	done

	return 1
}

#
#
err_check() {
	if [ $? != 0 ]; then
		rmsg "$1"
		exit 1
	fi
}

#
#
atom_parse() {
	T=""
	N=""
	V=""
	R=""
	PBSDIR=""
	local atom
	local string="$1"

	if [ "x${string##*.}" = "xpbs" ]; then
		local pbsfile="$(readlink -f $string)"
		if [ -f "$pbsfile" ]; then
			PBSDIR="${pbsfile%/*.pbs}"
			# filesdir contains patchs and user-defined files 
			filesdir="$PBSDIR"/files/
		fi
	fi

	if echo "$string" |grep -q "/"; then
		# /var/ybs/pbslib/net-ftp/lftp/lftp_4.3.3.pbs
		if echo "$string" |grep -q "$YPPATH_LIB"; then
			atom=${string##*/}
			T=${string%/*}
			T=${T%/*}
			T=${T##*/}
			string="$atom"
		fi
	
		# net-ftp/lftp_4.3.3.pbs
		if echo "$string" |grep ^[a-z] |grep -q "/"; then
			T=${string%%/*}
			atom=${string##$T/}
			string=$atom
		fi
		[ "x$atom" = "x" ] && string=${string##*/}
	fi

	case x${string##*.} in
		xpbs)           
 	  atom="${string%.pbs}" ;;
		x$PACK_SUFFIX)     
	  [ "x$YARCH" != "x" ] && atom="${string%-$YARCH.$PACK_SUFFIX}" || atom="${string%.$PACK_SUFFIX}" ;;
		xlist)	
	  atom="${string%.list}" ;;
		xdesc)	
	  atom="${string%.desc}" ;;
		*)      
 	  atom="$string"
	esac

	# Only digit
	if [ "x$(echo $atom |tr -d '[:digit:]' |tr -d '.' |tr -d '-')" = "x" ]; then
		atom=foo_$atom
	fi

	[ "x$ARCH" = "x" ] && ARCH="$(uname -m)"

	atom=${atom%-$ARCH}
	atom=${atom%-any}

	# cairo(>=1.6) x11-libs/cairo(>=1.6)
	if echo $atom |grep \( |grep -q \); then
		N=${atom%%(*)}
		VR="${atom##$N}"
		VR=$(echo $VR |tr -d '[:blank:]')
		return 0
	fi

	N=${atom%%_[0-9]*}
	N=${N%%_}
	VR=${atom#$N}
	VR=${VR#_}
	#V=${VR%%-[a-zA-z]*}
	V=${VR%%-*}
	R=${VR##$V}
}

#
# Compare 2 atoms
# 1、linux_2.6.9.pbs and linux_2.6.10.pbs
# 2、2.6.9 2.6.10
# 3、/var/ybs/pbslib/app-editors/leafpad/leafpad_0.8.17.pbs /var/ybs/pbslib/app-editors/leafpad/leafpad_0.8.18.pbs
# 4、1.2.3 3.2.1
# the former > the latter, return 1
# the former < the latter, return 2
# the former = the latter, return 0
# alpha < beta < rc < ylmf

string_len() {
	local string=$1
	local sep=$2
	local i
  	if [ "x$sep" = "x" ]; then
		i=($(echo $string |awk '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	else
	        i=($(echo $string |awk -F$sep '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	fi  
        echo ${#i[@]}
}

atom_cmp() {
        local string1="$1"
	local string2="$2"
	local v1 v2
	
	string1=${string1##*_}
	v1=${string1%.pbs}
	v1=$(echo $v1 |tr '[A-Z]' '[a-z]')

	string2=${string2##*_}
	v2=${string2%.pbs}
	v2=$(echo $v2 |tr '[A-Z]' '[a-z]')

	if [ "x$v1" = "x$v2" ] || test $v1 -eq $v2 2>/dev/null;then
		return 0
	fi

	# seperator is -
	local v1=($(echo $v1 |awk -F- '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	local v2=($(echo $v2 |awk -F- '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	[ "1${#v1[@]}" -lt "1${#v2[@]}" ] && maxnum=${#v2[@]} || maxnum=${#v1[@]}

	for ((i=0; i<maxnum; i++)); do
		a=${v1[i]}.
		b=${v2[i]}.
		# seperator is dot .
		a_len=$(string_len $a .)
		b_len=$(string_len $b .)
		[ "$a_len" -lt "$b_len" ] && max=$b_len || max=$a_len

		for ((j=0; j<max; j++)); do
			c=${a%%.*}
			d=${b%%.*}

			coa=$(echo $c |tr -d '[:digit:]' |tr -d '[:punct:]')
			doa=$(echo $d |tr -d '[:digit:]' |tr -d '[:punct:]')
			cod=$(echo $c |tr -d '[:alpha:]' |tr -d '[:punct:]')
			dod=$(echo $d |tr -d '[:alpha:]' |tr -d '[:punct:]')

			coa=${coa:-n}
			doa=${doa:-n}
			cod=${cod:-0}
			dod=${dod:-0}

			if [ "x$coa" = "x$doa" ]; then
				[ $cod -gt $dod ] && return 1
				[ $cod -lt $dod ] && return 2
			else
				case $coa$doa in
					rcn|betan|alphan) return 2 ;;
				        nrc|nbeta|nalpha) return 1 ;;
				                   ylmfn) return 1 ;;
				                   nylmf) return 2 ;;
				          rcbeta|rcalpha) return 1 ;;
				                  betarc) return 2 ;;
				               betaalpha) return 1 ;;
				       alpharc|alphabeta) return 2 ;;
			       rcylmf|betaylmf|alphaylmf) return 2 ;;
			       esac
			 fi
			 a=${a#*.}
			 b=${b#*.}
		done
	done

	return 0
}

#
# Search packages
#

#
# $1 $T 
# $2 $N
# $3 $V$R (this is the newest version) 
#
ypkg_searchInstalled() {
	local pkgtype=$1
	local pkgname=$2
	local pkgver=$3

	INSTALL_STATUS=$(yget --show $pkgname |grep Status |head -n1 |awk '{print $2}')
	
	case "x$INSTALL_STATUS" in
	 	x[IUD])
	   	  	INSTALL_TIME=$(yget --show $pkgname |grep Install_date |head -n1 |awk '{print $2" "$3}')
			INSTALL_VERSION=$(yget --show $pkgname |grep Version |head -n1 |awk '{print $2}')
			new=$pkgver
			old=$INSTALL_VERSION
			# Compare 2 versions
			# Return 0 if same.
			# Return 1 if $1 is grater than $2
			# Return 2 if $1 is lesser then $2
	       		atom_cmp $old $new
			case $? in
				1) 
				   INSTALL_STATUS="downgrade"
				   gmsg_ "[D] "  ;;
			        2) 
				   INSTALL_STATUS="upgrade"
				   gmsg_ "[U] " ;; 
				0) 
				   INSTALL_STATUS="installed"
				   gmsg_ "[I] "
			esac 
			echo "$(wmsg $pkgtype/$pkgname)"
			echo -e "\t$(gmsg Installed:) $(ymsg $INSTALL_VERSION) $INSTALL_TIME" ;;
	  	    *) 
			msg_ "[*] "
			echo "$(wmsg $pkgtype/$pkgname)"
	   		echo -e "\t$(gmsg "Installed:") None"
	  		INSTALL_STATUS="uninstall"
	esac
}

#
#
allver_msg() {
	local pbsfile
	local msg
	local extra="$BUILD_TIME $INSTALL_SIZE $PACK_SIZE"

	for pbsfile in $ALL_PBSFILE; do 
		atom_parse $pbsfile
		. $pbsfile
		case $REPO in
		        [Tt]esting) repo="t"  ;;
		         [Ss]table) repo="s" ;;
   	               [Uu]nusable) repo="u" ;;
                                 *) repo="s"
		esac
		[ "x$msg" = "x" ] && msg="$(mmsg $V$R[$repo]) $extra" || msg+=" | $(mmsg $V$R[$repo]) $extra"
	done
	echo $msg
}

#
#
ypkg_search() {
	local string="$1"
	local record=(AA)
	local pbsfile

	if ! ypkg_getpbsfile "$string" all; then
		rmsg "* $string not found."
		return 1
	fi
	
	for pbsfile in $ALL_PBSFILE; do
		atom_parse "$pbsfile"
		ypkg_getpbsfile $T/$N name

		str_isIn "${record[@]}" "$T/$N" && continue
		record[$count]="$T/$N"
	
		ypkg_searchInstalled $T $N $V$R

		echo -e "\t$(gmsg "Available:") $(allver_msg)"
		. $NEWEST
		echo -e "\t$(gmsg "Homepage:") $HOMEPAGE"
		echo -e "\t$(gmsg "Description:") $DESCRIPTION"
		echo 

		blank_funcs
	done
}

#
# Download packeage
#
do_download () {
	local uri="$1"
	local fname="$2"
	local target="$YPPATH_SOURCE/$fname.tmp"
	local wget="wget $WGET_OPTIONS"
	local curl="curl $CURL_OPTIONS"

	msg ">>> Downloading: ${uri}"
	case $DOWNLOAD_TOOL in
		wget)
		if [ "x$(echo $uri |cut -c 1-5)" == "xhttps" ];then	
			$wget --no-check-certificate $uri -O "$target" && return 0
		else
			$wget $uri -O "$target" && return 0
		fi	;;
		curl)
			$curl $uri -o "$target" && return 0
	esac

	return 1
}

# Check and download package
# $1 is URL
# $2 is local file name
# $3 is checksum value, md5sum/sha1sum/sha256sum, default is md5sum
#
check_and_download_raw() {
	local uri=$1
	local fname=$2
	local checksum=$3
	local download
	local checkok
	local target="${YPPATH_SOURCE}/${fname}"

	#
	case ${uri%%:*} in
		svn)
		cd ${YPPATH_SOURCE}
		local name="$N"
		cd $name && svn update || svn checkout ${1} "$N" ;;

		git)	
		local name=${fname%*.git}
		cd ${YPPATH_SOURCE}
		cd $name 2>/dev/null && git pull || git clone ${1} 
		[ "$?" == "0" ] && return 0 ;;

    http|https|ftp|*)	
		local checksum_server="$checksum"

		# target is exists and checksum_server is empty or checksum correct
		if [ -f "$target" ]; then
			if [ "x$checksum_server" = "x" ]; then
				msg ">>> $target exists without checksum." 
				return 0
			fi
			
			for checktool in $CHECK_TOOLS; do
				checksum_local=($($checktool "$target" 2>/dev/null))
				checksum_local="${checksum_local[0]}"
				if [ "x$checksum_local" = "x$checksum_server" ]; then
					msg ">>> $target exists and $checktool checked correctly." 
					return 0
				fi
			done
		fi

		# target is not exists or checksum fail 
		if [ -f "$target" ] || [ "x$checkok" != "xyes" ]; then
			rm -f "$target".tmp 2>/dev/null

			if do_download $uri $fname; then
				download="done"
			else
				# Try ylmfos dist source
				uri="$YPPATH_DIST_URI/${fname}"
				do_download $uri $fname && download="done" || download="error"
			fi

			if [ "x$download" = "xdone" ]; then
				# Check again
				for checktool in $CHECK_TOOLS; do
					checksum_local=($($checktool "$target".tmp 2>/dev/null))
					checksum_local="${checksum_local[0]}"
					if [ "x$checksum_local" = "x$checksum_server" ] || [ "x$checksum_server" = "x" ]; then
						gmsg ">>> Rename: $target"
						gmsg ">>> $checktool: $checksum_local"
						checkok="yes"
						mv "$target".tmp "$target" 
						return 0
					else
						continue	
					fi
				done

				if [ "x$checkok" != "x$yes" ] ;then
					rmsg ">>> "$target".tmp download successfully but $checktool checked failed."				
				        return 1
				fi
			fi
		fi
	esac

	return 1
}

#
# $1 - strings
# $2 - all/name
# resules:
# ALL_PBSFILE : all version pbs files with full path 
# $NEWEST: newest or specifid version pbs files with full path
# 
ypkg_getpbsfile() {
	NEWEST=""	
	local files_ready
	local files_ready_raw
	local string="$1"
	local range="$2"
	local min
	local max
	local iname
	
	atom_parse "$1"
	local find_dir="${PBSDIR}"
	[ "x$find_dir" = "x" ] && find_dir=$YPPATH_LIB	

	if [ "x$N" == "x" ]; then
		echo "No package specified."
		return 1
	fi

	local count=0
	if [ "x$find_dir" = "x$YPPATH_LIB" ]; then
		local dir=$(find $find_dir/$T -maxdepth 2 -type d -iname "$N")
		for pack in $dir; do let "count++"; done
		
		if [ "$count"0 -gt 10 ]; then
			rmsg "Too more results: "
		        echo $dir
		        return 1
		fi
	fi

	VR="$(echo $VR |tr -d '()')"
	
	case $range in
		all)   iname="*${N}*.pbs" ;;
	       name|*) iname="${N}_*.pbs"
	esac


	local pbsfiles=($(find $find_dir/"$T" -maxdepth 3 -type f -iname "$iname"))
	
	if [ "x$pbsfiles" = "x" ]; then
		# Fixme!
		# find provide
		pbsfiles=($(find $find_dir/"$T" -maxdepth 3 -type f -iname "*.pbs" |xargs grep PROVIDE  |grep -w "$N" |awk -F: '{print $1}'))
	fi	

	[ "x$pbsfiles" = "x" ] && return 1

	case $range in
		all)  ALL_PBSFILE="${pbsfiles[@]}"
		      return 0 ;;
		name) ALL_PBSFILE="${pbsfiles[@]}"
	esac
	
	case x$VR in
		x\>[[:digit:]]*)	
        		min=${VR#>} 
			for file in ${pbsfiles[@]}; do
	        		atom_cmp $min $file
				[ $? -eq 2 ] && files_ready+="$file "
			done	;;

		x\>\=[[:digit:]]*) 
        		min=${VR#>=} 
			for file in ${pbsfiles[@]}; do
	        		atom_cmp $min $file
				[ $? -ne 1 ] && files_ready+="$file "
			done	;;
			
		x\<[[:digit:]]*)	 
			max=${VR#<}
			for file in ${pbsfiles[@]}; do
				atom_cmp $max $file
				[ $? -eq 1 ] && files_ready+="$file "
			done ;;

		x\<\=[[:digit:]]*)
			max=${VR#<=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $max $file
				[ $? -ne 2 ] && files_ready+="$file "
			done ;;

		x\!\=[[:digit:]]*) 
			min=${VR#!=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				[ $? -ne 0 ] && files_ready+="$file "
			done ;;

		x\=[[:digit:]]*)	
		        min=${VR#=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				[ $? -eq 0 ] && files_ready+="$file "
			done	;;

			*)
			min=${VR}	
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				if [ $? -eq 0 ]; then
					NEWEST="$file"
					atom_parse $NEWEST
					return 0
				else	
					files_ready+="$file "
				fi
			done
	esac

	[ "x$files_ready" = "x" ] && return 1 || files_ready=($files_ready)

	for file in ${files_ready[@]}; do
		blank_funcs pbs
		. $file
		case $REPO in
			[Tt]esting)  
		  [ "x$ACCEPT_REPO" = "xtesting" ] && files_ready_raw+="$file " || continue  ;;
		         *)
		  files_ready_raw+="$file "
		esac
	done

	files_ready_raw=($files_ready_raw)
	NEWEST=${files_ready_raw[0]}	

	for file in ${files_ready_raw[@]}; do
		atom_cmp $file $NEWEST
		[ "$?" == "1" ] && NEWEST=$file
	done
	
	if [ "x$NEWEST" != "x" ]; then
		atom_parse $NEWEST
		return 0
	fi

	return 1
}

#
# $1 - pbsfile with full path, as is NEWEST
ypkg_begin_download() {
	local url
	local pbsfile="$1"

	ymsg ">> $T/${N}_$V$R begin download."

	blank_funcs pbs

	config="$YPINST_PREFIX "
	config="--prefix=/usr
		--sysconfdir=/etc
		--libdir=/usr/lib
		--localstatedir=/var
		--infodir=/usr/share/info
		--mandir=/usr/share/man
		--enable-shared "
		#--disable-static

	YPPATH_SCRIPT="$YPPATH_LIB/$T/$N"

	if [ -f "$pbsfile" ];then
		. $pbsfile
		err_check "* [Error]: $pbsfile is invalid! "
	else
		err_check "* [Error]: $1pbsfile not found"
	fi

	mkdir -p $YPPATH_SOURCE
	err_check "* [Error]: Create dir $YPPATH_SOURCE failed."

	# download all files
	if [ "x${SRC_URI}" != "x" ]; then
		local count=0
		local checksum=""

		# CHECKSUM: $SRC_URI in pbs file has md5sum/sha1sum/sha256sum value one by one.
		checksum=($CHECKSUM)
		
		for url in ${SRC_URI}; do
			# url localfile checksum
			check_and_download_raw $url $(basename $url) ${checksum[$count]}
			err_check "* [Error]: Download $url failed."
			let count=count+1
		done
	fi

	return 0
}

#
#
ypkg_download() {
	local string="$1"
	ypkg_getpbsfile "$string"

	if [ "$?" == "0" ]; then
		# found, download it
		ypkg_begin_download $NEWEST
		return 0
	fi

	rmsg "* [Error]: $string not found."
	return 1
}


#
# Strip unnessesary i18n in path $1
ypkg_strip_i18n() {
	local ipath="$1/usr/share/locale"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns; do
		name=${i##*/}
		str_isIn "$YP_I18N" $name 
		if [ "$?" == "1" ]; then
			# not in YP_I18N, remove.
			# msg ">>> strip i18n $name.."
			rm -rf $ipath/$name
		fi
	done
}

#
# strip unnessesary i18n in man path.
ypkg_strip_mani18n() {
	local ipath="$1/usr/share/man"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns; do
		name=${i##*/}

		# skip man1 -- man9
		str_isIn "$name" "man"
		if [ "$?" == "1" ]; then
			continue
		fi

		str_isIn "$YP_I18N" $name 
		if [ "$?" == "1" ]; then
			# not in YP_I18N, remove.
			# msg ">>> strip man-i18n $name.."
			rm -rf $ipath/$name
		fi
	done
}

#
# Upx for compressing eXecutables files
ypkg_upx_bin () {
	local dir="$1"
	find "$dir"/{,usr/}{bin,sbin} -type f -executable 2>/dev/null |while read file; do
		if ! upx -9 $file >/dev/null 2>&1; then
			[ -f $file.upx ] && rm -rf $file.upx
		fi
	done
}

#
# Strip binary in directory $1
ypkg_strip_bin() {
	local dir="$1"
	#find "$dir"/{,usr/}{bin,sbin} -type f -exec strip --strip-all '{}' ';' 2>/dev/null
	#find "$dir"/{,usr/}{lib,local/lib} -type f -exec strip --strip-debug '{}' ';' 2>/dev/null
	find "$dir" |xargs file |grep "executable" |grep ELF |cut -f 1 -d : |xargs strip --strip-unneeded 2> /dev/null
	find "$dir" |xargs file |grep "shared object" |grep ELF |cut -f 1 -d : |xargs strip --strip-unneeded 2> /dev/null
}

#
# Compress man doc and info 
ypkg_gzip_extra() {
	local dir="$1"
	rm "$dir"/usr/share/info/dir 2>/dev/null
	find "$dir"/usr/{,share/}{man,doc,info} -type f -exec gzip -9 '{}' ';' 2>/dev/null
}

# System Xorg Desktop Utilities Network Games Graphics Video             
# Audio Office Development Security Science-education Drivers
# Multimedia Misc Non-free
#
ypkg_get_category() {
	local type  category
	type=$1
	case ${type%%-*} in
 	 #	 sys)	category="System"		;;
	 #       x11)    category="Xorg"		;;
#gnome|kde|lxde|xfce)    category="Desktop"		;;
		#app)	category="Utilities"		;;
sys|x11|gnome|kde|lxde|xfce|app)
		        category="Utilities"            ;;
       www|net|mail)	category="Network"		;;
       		 im)    category="IM"		        ;;
    	      games)	category="Games" 		;;
    	   graphics)	category="Graphics" 		;;
    	      media)	category="Multimedia" 		;;
     printer|office)	category="Office" 		;;
    	        dev)	category="Development" 		;;
    	   security)	category="Security" 		;;
	    drivers)    category="Drivers"		;;
      education|sci)	category="Science-education"    ;;
		non)	category="Non-free"		;;
    	       misc)	category="Misc"                 ;;
    	          *)	category="Misc"                 ;;
	esac
	echo $category
}

#
split_dev() {
	local dir="$1"
	local destdir="$workdir"
	
	#/usr/include/ /usr/share/*/include /usr/lib/*/include
	ls -1d $dir/usr/share/*/include $dir/usr/lib/*/include \
	       $dir/usr/include 2>/dev/null |while read line; do
	        	local tmp=${line##$dir}
			local tmp=${tmp%%/include}
			domv $line $destdir/$N-dev_$V$R/$tmp
 		done
	
	#*.la *.a *.h
	devlib=$(find $dir/ -name "*.la" -o -name "*.a" 2>/dev/null)
	devlib+=" $(find $dir/ -name "*.h" 2>/dev/null)"
	if [ x"$devlib" != "x" ]; then
		for lib in $devlib; do
			i=${lib#$dir}
			libdir=${i%/*}
			domv $lib  $destdir/$N-dev_$V$R/$libdir
		done
	fi

	#pkgconfig
	pcdir=$(find $dir -type d -name "pkgconfig" 2>/dev/null)
	if [ x"$pcdir" != "x" ]; then
		for pc in $pcdir; do
			i=${pc#$dir}
			dirpc=${i%/*}
			domv $pc $destdir/$N-dev_$V$R/$dirpc
		done
	fi
	
	#/usr/share/aclocal/ogg.m4
	acl=$(ls -d $dir/usr/share/aclocal/* 2>/dev/null)
	if [ x"$acl" != "x" ]; then
		domv $dir/usr/share/aclocal $destdir/$N-dev_$V$R/usr/share
	fi
	[ -d $destdir/$N-dev_$V$R ] && echo $destdir/$N-dev_$V$R && return 0
	
	return 1
}

#
split_doc() {
	local dir="$1"
	local destdir="$workdir"
	docs=$(ls -d $dir/usr/share/doc/* 2>/dev/null)
	
	#info=$(ls -d $dir/usr/share/info/* 2>/dev/null)
	gtk_docs=$(ls -d $dir/usr/share/gtk-doc/html/* 2>/dev/null)
	if [ x"$docs" != "x" ]; then
		domv $dir/usr/share/doc $destdir/$N-doc_$V$R/usr/share
	fi
	
	#if [ x"$info" != "x" ]; then
	#	domv $dir/usr/share/info $destdir/$N-doc_$V$R/usr/share
	#fi
	if [ x"$gtk_docs" != "x" ]; then
		domv $dir/usr/share/gtk-doc/html $destdir/$N-doc_$V$R/usr/share/gtk-doc
	fi
	
	#ypkg_gzip_info $destdir/$N-doc_$V$R
	[ -d $destdir/$N-doc_$V$R ] && echo $destdir/$N-doc_$V$R && return 0
	return 1
}


#
split_i18n() {
	local dir="$1"
	local localdir="usr/share/locale"
	if ls -d $dir/$localdir/* >/dev/null 2>/dev/null; then
		ls -d $dir/$localdir/* |while read line;do
			lang=${line##*/}
			domv $dir/$localdir/$lang      $workdir/$N-i18n-${lang}_$V$R/$localdir
			echo $workdir/$N-i18n-${lang}_$V$R
		done
		return 0
	fi
	return 1
}

#
find_desktop() {
	local source_dir=$1
	local desktop=""
	file_is_exist "$source_dir/usr/share/applications/$N-gtk.desktop" && \
		desktop="$source_dir/usr/share/applications/$N-gtk.desktop"
	file_is_exist "$source_dir/usr/share/applications/$N-[[:digit:]].desktop" && \
		desktop="$(ls $source_dir/usr/share/applications/$N-[[:digit:]].desktop)"
	file_is_exist "$source_dir/usr/share/applications/$N.desktop" && \
		desktop="$source_dir/usr/share/applications/$N.desktop"

	if [ "x$DESKTOPFILE" != "x" ]; then
		file_is_exist "$source_dir/$DESKTOPFILE" && \
			desktop="$source_dir/$DESKTOPFILE"
		file_is_exist "$source_dir/usr/share/applications/$DESKTOPFILE" && \
			desktop="$source_dir/usr/share/applications/$DESKTOPFILE"
	fi

	if [ "x$desktop" != "x" ]; then
		echo "$desktop"
		return 0
	fi

	return 1
}

#
find_icon() {
	local desktop=$1 
	local source_dir=$2
	local icon_name="$(grep ^Icon= $desktop |sed -e 's/Icon=//g')"

	if file_is_exist "$source_dir/$icon_name"; then
		icon="$source_dir/$icon_name"
	else
		file_is_exist "$source_dir/usr/share/icons/hicolor/scalable/apps/$icon_name.svg" && \
		icon="$source_dir/usr/share/icons/hicolor/scalable/apps/$icon_name.svg"
		icon_name=${icon_name%.svg}
		icon_name=${icon_name%.png}
		icon_name=${icon_name%.xpm}
		icon_name=${icon_name%.jpg}

		for i in 48x48 32x32 24x24 22x22; do
			icon="$source_dir/usr/share/icons/hicolor/"$i"/apps/$icon_name.png"
			file_is_exist "$icon" && break || continue
		done

	fi

	file_is_exist "$source_dir/usr/share/icons/$icon_name.png" && \
		icon="$source_dir/usr/share/icons/$icon_name.png"
	file_is_exist "$source_dir/usr/share/icons/$icon_name.xpm" && \
		icon="$source_dir/usr/share/icons/$icon_name.xpm"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.svg" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name.svg"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.xpm" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name.xpm"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.png" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name.png"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name"

	if [ "x$ICONFILE" != "x" ]; then
		file_is_exist "$source_dir/$ICONFILE" && icon="$source_dir/$ICONFILE"
		file_is_exist "$source_dir/usr/share/pixmaps/$ICONFILE" && \
			icon="$source_dir/usr/share/pixmaps/$ICONFILE"
	fi

	if [ "x$icon" != "x" ] && file_is_exist "$icon"; then
		echo "$icon"
		return 0
	fi

	return 1
}

#
# $1 - source_dir
mkpackage() {
	local sha
	local pbsfile
	local atom
	local source_dir="$1"  
	atom_parse $source_dir
	local dbdir="${YPPATH_DB#/}/$N"
	
	# Creat pkgdate
	cd $source_dir
	
	find |sort -r |fileinfo > $workdir/${N}_$V$R.list

	if [ "x$N" = "x$NN-dev" ]; then
		RDEPEND=
		BDEPEND=
		RECOMMENDED=
		PRIORITY=
		INSTALL=
		CONFLICT=
		DESCRIPTION="$DESCRIPTION (development files)" 
	else
		install=$INSTALL
		
		if [ "x$install" != "x" ] && file_is_exist "$filesdir"/$install; then
			docp "$filesdir"/$install $dbdir
		fi
	fi
	
	build_date="$(date +%s)"
	declare -a install_size=($(du $source_dir -sb))
	install_size=${install_size[0]}
	
	#creat pkginfo
	#
	cd ..

	pkgdir="${N}_$V$R-pkginfo"
	mkdir -p $pkgdir

	category=$(ypkg_get_category "$TT")
	name=$N
	version=$V$R
	priority=$PRIORITY
	[ x"$REPO" = x ] && REPO="stable"
	repo=$REPO
	subdir="$(echo $N |cut -b1)"
	uri="$subdir/${N}_$V$R-$YARCH.$PACK_SUFFIX"
	license="$(echo $LICENSE |tr -d '<>')"
	packager="$(echo $PACKAGER |tr -d '<>')"
	homepage="$(echo $HOMEPAGE |tr -d '<>')"
	install="$INSTALL"
	arch="$YARCH"
	depend=$(echo $RDEPEND |xargs |tr " " ",")
	bdepend=$(echo $BDEPEND |xargs |tr " " ",")
	redepend=$(echo $RECOMMENDED |xargs |tr " " ",")
	conflict=$(echo $CONFLICT |xargs |tr " " ",")
	description=$(echo $DESCRIPTION |sed 's/&/and/g' |tr -d '<>')

	cd $source_dir
	find . |$CPIO --quiet -o -H newc |$XZ -7 >../$pkgdata
	size=($(du ../$pkgdata -sb))
	size=${size[0]}
	
	cd ..
	local gname
	local gdescription
	
	# desktop and icon
	local desktop=$(find_desktop $source_dir)

	if [ "x$desktop" != "x" ]; then
		cp $desktop  $pkgdir/"$N".desktop
		cp $desktop  $YPPATH_PACKAGE/desktops/"$N".desktop
		local icon=$(find_icon $desktop $source_dir)
		
		if [ "x$icon" != "x" ]; then
			local tmp="$N"."${icon##*.}"
			cp $icon  $pkgdir/$tmp
			cp $icon  $YPPATH_PACKAGE/icons/$tmp
		fi
	
		# Find exec
			
		if grep -q ^Exec= "$desktop"; then
			exec="$(grep ^Exec= "$desktop" |sed 's/^Exec=//g')"
		fi
	
		if grep -q ^TryExec= "$desktop"; then
			tryexec="$(grep ^TryExec= "$desktop" |sed 's/^TryExec=//g')"
		fi
		
		exec="${exec-$tryexec}"
		gname="genericname type=\"desktop\""
		gdescription="description type=\"desktop\""
	else
		gname="genericname"
		gdescription="description"
	fi

	data_count="1"
	
	cat >$pkgdir/$control <<OOO
<?xml version="1.0" encoding="UTF-8"?>
<PackageInfo>
 <Package name="$name">
   <$gname>
     <keyword lang="en">$name</keyword>
   </genericname>
   <category>$category</category>           
   <arch>$arch</arch>                                        
   <version>$version</version>                            
   <priority>$priority</priority>                    
   <license>$license</license>
   <packager>$packager</packager>
   <homepage>$homepage</homepage>
   <repo>$repo</repo>
   <install>$install</install>
OOO

if [ "x$exec" != "x" ]; then
       cat >>$pkgdir/$control <<OOO
   <exec>$exec</exec>
OOO
fi

cat >>$pkgdir/$control <<OOO
   <build_date>$build_date</build_date>    
   <uri>$uri</uri>
   <$gdescription>
     <keyword lang="en">$description</keyword>
   </description> 
   <data_count>$data_count</data_count>
   <data id="0">                                                     
     <name>pkgdata</name>                           
     <format>xz</format> 
     <size>$size</size>
     <install_size>$install_size</install_size>        
     <depend>$depend</depend>              
     <bdepend>$bdepend</bdepend>
     <recommended>$redepend</recommended>      
     <conflict>$conflict</conflict>      
   </data>                               
 </Package>
</PackageInfo>
OOO

	cd $pkgdir
	cp $workdir/${N}_$V$R.list $filelist
	
	if [ "x$install" != "x" ] && file_is_exist $filesdir/$install; then
		cp $YPPATH_SCRIPT/files/$install .
	fi
	
	tar cjf ../$pkginfo *

	# Creat ypkg package
	cd ..
	
	if [ "x$2" != "x" ]; then
		target="$2"
		tar cjf $target $pkgdata $pkginfo && echo $target
	else
		mkdir -p $YPPATH_PACKAGE/$subdir
		tar cjf $YPPATH_PACKAGE/$uri $pkgdata $pkginfo && echo $YPPATH_PACKAGE/$uri
	fi
}

# Check /dirs permission
check_perm_dirs () {
	local dir="$1"
	for i in tmp root proc sys; do	
		[ -d $dir/${i} ] && rm -rf $dir/${i}
	done

	for i in bin boot dev etc home lib media mnt opt sbin usr var; do
		if [ -d $dir/${i} ];then
			chown root:root $dir/${i}
			chmod 755       $dir/${i}
		fi
	done

	chmod +r /usr/share/applications/*.desktop 2>/dev/null
}

#
# $1- destdir
# 
ypkg_mkpackage() {
	[ ! -d $destdir ] && return 0

	# Source packages
	local spacks="$1 "
	NN="$N"

	#check /dirs permission
	check_perm_dirs "$destdir"

	if [ "x$YP_I18N" != "x" ];then
		#strip i18n 
		ypkg_strip_i18n $destdir
			
		#strip unnessesary i18n in man path.
		ypkg_strip_mani18n $destdir
	fi

	# Strip bin
	if ! str_isIn "$OPTIONS" "nostrip"; then
		ypkg_strip_bin $destdir
	fi

	# Upx executables files
	if str_isIn "$OPTIONS" "upx"; then
		ypkg_upx_bin $destdir
	fi

	# Split i18n
	#spacks+="$(split_i18n $destdir) "

	# Split dev
	if ! str_isIn "$OPTIONS" "nodev"; then
		spacks+="$(split_dev $destdir) "
	fi

	# Split_doc
	#spacks+="$(split_doc $destdir) "

	# Compress man doc info
	ypkg_gzip_extra $destdir

	# Mkpackges one by one
	for pack in $spacks; do
		# skip empty dirs
		local files=$(find $pack -type f)
		[ "x$files" = "x" ] && continue
		mkpackage "$pack"
	done
	return 0
}

# Cp desktop file to "$destdir"/usr/share/applications
dodesktop() {
	local dfile="$1"
	local picture="$2"
	local icon=""
	file_is_exist "$filesdir/${dfile##*/}"   && dfile="$filesdir/${dfile##*/}"
	file_is_exist "$filesdir/${picture##*/}" && picture="$filesdir/${picture##*/}"
	if [ x"$dfile" != x ] && file_is_exist "$dfile"; then
		mkdir -p "$destdir"/usr/share/applications
		install -m755 "$dfile" "$destdir"/usr/share/applications 
	fi
	if [ x"$picture" != x ] && file_is_exist "$picture"; then 
		docp "$picture"   "$destdir"/usr/share/pixmaps
	fi
	dfile="${dfile##*/}"
	picture="${picture##*/}"
	icon=$(grep ^Icon= "$destdir"/usr/share/applications/"$dfile" |sed 's/Icon=//g')
	name=${icon%.*}
	type=${picture##*.}
	if [ x"$type" != x ] && [ x"$picture" != x"$name.$type" ]; then 
		mv "$destdir"/usr/share/pixmaps/"$picture" "$destdir"/usr/share/pixmaps/"$name"."$type" 
	else
		return 0
	fi
}

# Add unit for systemd
dounit() {
	local file="$@"
	if [ x"$file" != x ]; then
		for i in $@; do
			if file_is_exist "$i"; then
				docp "$i" "$destdir"/lib/systemd/system
			else
				docp "$filesdir/$i"  "$destdir"/lib/systemd/system
			fi
		done
	fi
}

# Cp script to "$destdir"/etc/init.d
doinit() {
	local file="$1"
	mkdir -p "$destdir"/etc/init.d
	if [ x"$file" != x ]; then
		if file_is_exist "$file"; then
       			install -m755 "$file" "$destdir"/etc/init.d
		else
       			install -m755 "$filesdir/$file" "$destdir"/etc/init.d
		fi
	fi
}

#
# for reboot flag
#
flag_reboot() {
	local flag="/run/ypkg/reboot"
	mkdir -p /run/ypkg
	touch "$flag"
}

#
# Kernel modules make/mkinstall automatically
# 
ykms() {
	# $1 action: build delete
	# $2 name
	# $3 version
	# e.g: /usr/src/rtl8101_1.020.00
	# name=rtl8101
	# version=1.020.00
	
	local show_usage=
	[ "x$1" = "x" ] && show_usage=yes
	case "$1" in 
		 install|remove|autoinstall) : ;;
		 *)	show_usage=yes
	esac
	
	if [ "x$show_usage" = "xyes" ]; then
		 msg "Usage: "
			msg "ykms build name version"
			msg "ykms install name version"
			msg "ykms remove name version"
			msg "ykms autoinstall"
			return 0
	fi

	local action="$1"
	local name="$2"
	local version="$3"
	local args="$4 $5 $6"
	local dir="$YPKPATH/modules"
	local source_dir="/usr/src/"${name}_$version""

	if [ "x$action" != "xautoinstall" ]; then
		if [ ! -d $source_dir ]; then
			rmsg "* $source_dir: not such directory"
			return 1
		fi
	fi

	#
	case "$action" in 
	install)
		cd $source_dir
		local    preparelog="$PWD/prepare-log"
		local       makelog="$PWD/make-log"
		local  mkinstalllog="$PWD/mkinstall-log"
		local  post_instlog="$PWD/post_inst-log"

		[ -f ./ykms.conf ] && . ./ykms.conf

		#if [ "x$patches" != "x" ]; then
		#	msg "* ${name}_$version kernel modules patching." 
		#	for patch in $patches; do
		#		dopatch "$patch"
		#	done
		#
		#fi

		if [ "x$prepare" != "x" ]; then
			msg "* ${name}_$version kernel modules preparing." 
        	        if ! eval $prepare >$preparelog 2>&1; then 
				rmsg "* [Error]: prepare kernel modules failed!"
			        rmsg "* prepare log: $preparelog"
		                return 1
			fi
		fi   

		msg "* ${name}_$version kernel modules compiling."
		if ! make $MAKEOPTS $make_args >$makelog 2>&1; then
			rmsg "* [Error]: build kernel modules failed!"
			rmsg "* build log: $makelog"
			return 1
		fi	

		msg "* ${name}_$version kernel modules installing."
		if [ "x$mkinstall_args" = "x" ]; then
			command="make $MAKEOPTS install"
		else
			command="make $MAKEOPTS $mkinstall_args"
		fi
		if ! eval "$command" >$mkinstalllog 2>&1; then
			rmsg "* [Error]: install kernel modules failed!"
			rmsg "* install log: $mkinstalllog"
			return 1
		fi
		
		#
		local record="$dir"/"$name"/"$version"/"$(uname -m)"/"$(uname -r)"
		mkdir -p $record
		>$record/modules
		find . -type f -name "*.ko" |sort -u |while read i; do
			local origin="$i"
			local name=${i##.*/}
			local target="$(find /lib/modules/"$(uname -r)" -type f -name ${i##*/} |head -n1)"
			if diff $origin $target >/dev/null 2>&1; then	
				msg "$name -> $target"
				sha1sum $target |while read sha1 name; do 
					echo $name $sha1 >>$record/modules
				done
			fi
		done 
		#
		make $MAKEOPTS clean >/dev/null 2>&1

		if [ "x$post_inst" != "x" ]; then
			msg "* ${name}_$version kernel modules post install." 
        	        if ! eval $post_inst >$post_instlog 2>&1; then 
				rmsg "* [Error]: post install kernel modules failed!"
			        rmsg "* post_inst log: $post_instlog"
		                return 1
			fi
		fi   

		#

		rm -rf $makepipe $makelog $mkinstallpipe $mkinstalllog $preparelog 2>/dev/null 	
		;;
	remove)
		local record="$dir"/"$name"/"$version"/"$(uname -m)"/"$(uname -r)"
		cat $record/modules |while read file sha1; do
			sha1_old=${sha1}
			#file=($(find /lib/modules/"$(uname -r)" -type f -name "${name}" -exec sha1sum {} \;))
			if [ -f $file ]; then
				file=($(sha1sum $file))
				sha1_new=${file[0]}
			fi

			if [ "x$sha1_old" = "x$sha1_new" ]; then
				msg "<< file: ${file[1]}"
				rm -f ${file[1]}
			fi
		done
		
		msg "<< file: $record/modules"
		rm -f $record/modules
		
		#if [ -d $source_dir ]; then
		#	msg "<< dir: $source_dir"
		#	rm -rf $source_dir 2>/dev/null  
		#fi

		rmdir -p $record 2>/dev/null  
		;;

	autoinstall)
		ls -d1 "$dir"/*/* 2>/dev/null |awk -F\/ '{print $5 " " $6}' |while read name version;do
			ykms install $name $version
			prepare=""
			make_args=""
			mkinstall_args=""
			post_inst=""
		done   ;;

		*)  :
	esac	

	return 0
}

# cp
docp() {
	local end=${!#}
	mkdir -p "$end"
	cp -a "$@"
}

# cp and rename
docp_rename() {
	local end=${!#}
	mkdir -p "$(dirname $end)"
	cp -a "$@"
}

# mv
domv() {
	local end=${!#}
	mkdir -p "$end"
	mv "$@"
}

# mv and rename
domv_rename() {
	local end=${!#}
	mkdir -p "$(dirname $end)"
	mv "$@"
}

# cp man to dir
doman() {
	local name num
	for i in $@; do
		name=${i%.[0-9]}
		num=${i##$name}
		num=${num##.}
		if file_is_exist "$i"; then
			docp ${i} "$destdir"/usr/share/man/man${num}/
		else
			docp "$filesdir/${i}" "$destdir"/usr/share/man/man${num}/
		fi
	done
}

# link
doln(){
	local end=${!#}
	mkdir -p "$(dirname $end)"
	#ln -sf "$1"  "$2"
	ln -sf $@
}

# font
dofont() {
	msg ">>> mkfontscale $1"
	mkfontscale "$1"
	msg ">>> mkfontdir $1"
	mkfontdir  "$1"
	msg ">>> fc-cache $1"
	fc-cache -f "$1"
}

#
doinstall_info () {
	msg ">>> install info: $@"
	[ -x /usr/bin/install-info ] || return 0
	infodir=/usr/share/info
	for i in $@; do
		install-info "$infodir"/"$i" $infodir/dir 2>/dev/null
	done	
	return 0
}

#
doremove_info () {
	msg ">>> remove info: $@"
	[ -x /usr/bin/install-info ] || return 0
	infodir=/usr/share/info
	for i in $@; do
		install-info --delete "$infodir"/"$i" $infodir/dir 2>/dev/null
	done
	return 0
}


# patch
dopatch(){
	local file=""
	local dir1=""
	local dir2=""
	local num=""
	while [ "x$1" != "x" ]; do
		file="$1"
		file_is_exist "$file" || file="$filesdir/$1"
		file_is_exist "$file" || file="$filesdir/patches/$1"
		if ! file_is_exist "$file"; then
			rmsg "* [Error]: \"$1\" not found."
			exit  1
		fi
		dir1="$(grep ^--- "$file" |head -n1 |awk '{print $2}' |awk -F/ '{print $1}' |tr -d '\r')"
		dir2="$(grep ^+++ "$file" |head -n1 |awk '{print $2}' |awk -F/ '{print $1}' |tr -d '\r')"
		if ls -d "$dir1" >/dev/null 2>/dev/null || ls -d "$dir2" >/dev/null 2>/dev/null;then
			num="0"
		else
			num="1"
		fi
		mmsg ">>> Patching ${file##*/}.."
		patch -p$num -i "$file" 
		shift
	done
}

#
dounpack() {
	if [ "x$SRC_URI" = "x" ];then
		for i in tar.bz2 tar.gz bz2 tgz tbz tbz2 rar zip 7z; do
			file_is_exist "$YPPATH_SOURCE/$N-$V$R.${i}" && SRC_URI="$YPPATH_SOURCE/$N-$V$R.${i}"
		done
	else
		file_is_exist "$SRC_URI" && SRC_URI="$SRC_URI"
		file_is_exist "$YPPATH_SOURCE/$SRC_URI" && SRC_URI="$YPPATH_SOURCE/$SRC_URI"
	fi

	[ "x$SRC_URI" = "x" ] && return 0
	SRC_URI=($SRC_URI)
	local fname=$(basename $SRC_URI)
	local tarball="$YPPATH_SOURCE/$fname"
	local srcdir="$N-$V$R"
	rm -r "$srcdir" 2>/dev/null
	
	case $fname in
		*.tar.*|*.gz|*.tar|*.tgz|*.tbz2|*.tbz|*.bz2)
			mmsg ">>> tar xf $tarball"
			name=($(tar -tf "$tarball" |awk -F/ '{print $1}' |sort -u))

			if [ "x$name" = "x." ] || [ ${#name[@]} -gt 1 ]; then
				mkdir "$srcdir"
				tar xf "$tarball" -C "$srcdir" && return 0
			fi 

			if [ ${#name[@]} -eq 1 ]; then
				tar xf "$tarball"
				[ "x$name" != "x$srcdir" ] && mv "$name" "$srcdir" || return 0
			fi
			;;

		*.zip)
			mmsg ">>> unzip xf $tarball"
			name=($(unzip -l "$tarball" |awk '{print $4}' |awk -F/ '{print $1}' |sort -u |sed -e '/^----$/d' -e '/^$/d' -e '/^Name$/d'))

			if [ ${#name[@]} -eq 1 ]; then
				unzip "$tarball"
				[ "x$name" != "x$srcdir" ] && mv "$name" "$srcdir" || return 0
			else
				unzip "$tarball" -d "$srcdir"
			fi
			;;

		 *.deb) 
		 	mmsg ">>> ar x $tarball"
                    	name=$(ar t "$tarball" |grep data)
			mkdir -p "$srcdir" && cd "$srcdir"
			ar x "$tarball"
			mkdir -p data 
			tar xf "$name" -C data && cd ../	 
			;;

		 *.rpm) 
		 	mmsg ">>> unpack $tarball" 
			name=${fname%.rpm}
			mkdir -p "$srcdir" && cd "$srcdir"
		 	rpm2tarbz2 "$tarball"
			mkdir -p data
			tar xf $name.tar.bz2 -C data && cd ../
			;;

		*.7z)   
			mmsg ">>> 7z x $tarball"
			name=$(7z l "$tarball" |grep -A2 "Size   Compressed  Name" |tail -n1 |awk '{print $6}')	
			name=${name%%/*}
			7z x "$tarball" 
			[ "x$name" != "x$srcdir" ] && mv "$name" "$srcdir" || return 0
			;;
	       
	       *.git)
		        name=${fname%*.git}
		    	mmsg ">>> cp -a ${YPPATH_SOURCE}/"$name" $PWD/"$srcdir""
		        cp -a ${YPPATH_SOURCE}/"$name" "$srcdir"
			;;
	       
	       *.rar) 
			mmsg ">>> unrar xf $tarball"
			unrar x "$tarball"
			;;
	  
	       *.ar)   return 1
	esac
}

# Configure
doconfig() {
	local command=""
	local command1=""
	local command2=""
		
	# waf
	[ -x waf ] && command="./waf configure $(echo $config |xargs) $@"
	if [ x"$command" != x ];then
		mmsg ">>> $command"
		eval $command && return 0
	fi
	
	# generic
	[ -x configure ] && command="./configure $(echo $config |xargs) $@"
	[ -x Configure ] && command="./Configure $(echo $config |xargs) $@"
	if [ x"$command" != x ];then
		mmsg ">>> $command"
		eval $command && return 0
	fi

	# autogen
	if [ -x autogen.sh ];then
		command="./autogen.sh" 
		command1=" ./configure $(echo $config |xargs) $@"
	fi
	if [ x"$command" != x ];then
		mmsg ">>> $command; $command1"
		eval $command
		eval $command1 && return 0
	fi
	
	# perl module
	file_is_exist Makefile.pl && mv Makefile.pl Makefile.PL
	file_is_exist Makefile.PL && command="perl Makefile.PL -y PREFIX=/usr $@"
	if [ x"$command" != x ];then
		mmsg ">>> $command"
		if ! eval $command; then
			command="perl Makefile.PL PREFIX=/usr $@"
			mmsg ">>> $command"  
			eval $command && return 0
		else
			return 0
		fi
	fi

	# cmake
	if file_is_exist CMakeLists.txt; then
		command="mkdir -p build"
		command1="cd build"
		command2="cmake -D CMAKE_INSTALL_PREFIX=/usr $@ .." 
		mmsg ">>> $command; $command1; $command2"
		eval $command
		eval $command1
		eval $command2 && return 0
	fi

	# qmake
	if ls *.pro >/dev/null 2>/dev/null; then
		command="qmake $@"
		mmsg ">>> $command"
		eval $command && return 0
	fi

	# scons
	if file_is_exist SConstruct; then
		command="scons $(echo $config |xargs) $@"
		mmsg ">>> $command"
		eval $command 
	fi	
}

# Make
domake() {
	local command="make $MAKEOPTS $@"
	if [ -x waf ];then
		command="./waf build $MAKEOPTS $@"
		mmsg ">>> $command"
		eval $command && return 0
	fi
	if file_is_exist setup.py;then
		if [ "x$1"  = "xmake" ]; then
			command="make $MAKEOPTS $@"
		else
			command="python setup.py build $@"
		fi
		mmsg ">>> $command"
		eval $command && return 0
	fi
	if file_is_exist Makefile || file_is_exist GNUmakefile; then
		command="make $MAKEOPTS $@" 
	fi
	if file_is_exist makefile.linux; then
                command="make $MAKEOPTS -f makefile.linux $@"
	fi
	if file_is_exist Imakefile; then
		command="make $MAKEOPTS $@"
	fi
	if file_is_exist SConstruct; then
	        return 0
	fi

	mmsg ">>> $command"
	eval $command
}

# Make install
domkinstall() {
	local command="make DESTDIR="$destdir" "$@" install"
	if [ -x waf ];then
		command="./waf install --destdir="$destdir" $@"
		mmsg ">>> $command"
		eval $command && return 0
	fi
	if file_is_exist setup.py;then
		if [ "x$1"  = "xmake" ]; then
			command="make DESTDIR="$destdir" $@ install"		
		else
			command="python setup.py install --prefix=/usr --root="$destdir" $@"
		fi
		mmsg ">>> $command"
		eval $command && return 0
	fi
		
	if file_is_exist SConstruct;then
		if [ x"$@" = x ]; then
			command="scons --install-sandbox="$destdir" "$@" install"
		else
			command="scons "$@" install"
		fi
		mmsg ">>> $command"
		eval $command && return 0
	fi	

	if file_is_exist Makefile || file_is_exist GNUmakefile; then
		command="make DESTDIR="$destdir" "$@" install"
	fi

	mmsg ">>> $command"
	eval $command 
	ldconfig
}

# Cp src file to specified dir
dosrc() {
	mmsg ">>> Copy source files: /usr/src/"${N}_$V$R""
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	cp -a "$@" "$destdir"/usr/src/"${N}_$V$R"/
}

# Cp supported to specified dir
dosupported() {
	mmsg ">>> Copy supported file: $1"
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	install -m755 "$filesdir/$1" "$destdir"/usr/src/"${N}_$V$R"/"${N}"_supported
}

# Cp ykms.conf to specified dir
doykms() {
	mmsg ">>> Copy ykms file: ykms.conf"
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	install -m755 "$filesdir/ykms.conf" "$destdir"/usr/src/"${N}_$V$R"
}


# Cp doc to specified dir
dodoc() {
	mmsg ">>> Copy documents: $@"
	install -m755 -d "$destdir"/usr/share/doc/"$N"/
	cp -a "$@" "$destdir"/usr/share/doc/"$N"/
}

#
# Ypkg useradd
douseradd() {
	local end=${!#}
	local N=$end
	if ! getent passwd "$N" >/dev/null; then 
		msg ">>> Creating: user $N"
		useradd "$@"
	fi
}

#
# Ypkg userdel
douserdel() {
	local end=${!#}
	local N=$end
	if getent passwd "$N" >/dev/null; then 
		msg ">>> Deleting: user $N"
		userdel "$@"
	fi
}

#
# Ypkg groupadd
dogroupadd() {
	local end=${!#}
	local N=$end
	if ! getent group "$N" >/dev/null; then
		msg ">>> Creating: group $N"
		groupadd "$@"
	fi
}

#
#
# Ypkg groupdel
dogroupdel() {
	local end=${!#}
	local N=$end
	if getent group "$N" >/dev/null; then
		msg ">>> Deleting: group $N"
		groupdel "$@"
	fi
}

#
#
dolibtool_finish () {
	local dir="$@"
	msg ">>> Libtool finish: $dir"
	libtool --finish --silent $dir
}

#
perl_cleanup () {
	msg ">>> Delete: .packlist *.pod files"
	find "$destdir" -name '.packlist' -delete
	find "$destdir" -name '*.pod' -delete
}

#
glib_compile_schemas() {
	if [ -x /usr/bin/glib-compile-schemas ]; then
		msg ">>> glib-compile-schemas /usr/share/glib-2.0/schemas"
		/usr/bin/glib-compile-schemas  /usr/share/glib-2.0/schemas/
	else
		msg "* /usr/bin/glib-compile-schemas not found."
		return 1
	fi
	return 0
}

#
doinstall_catalog() {
	local bin=$(which install-catalog)
	if [ -x $bin ]; then
		$bin --add $@
	fi
}

doremove_catalog() {
	local bin=$(which install-catalog)
	if [ -x $bin ]; then
		$bin --remove $@
	fi
	
}

# Install defaut settings
gnome2_install_defaut_gconf() {
	#type
	local t=$1	
	#name
	local n=$2
	#value
	local v=$3
	msg ">>> Setting: \"$n\" \"$v\""
	if [ -x /usr/bin/gconftool-2 ]; then
		configfile=$(/usr/bin/gconftool-2 --get-default-source)
		if [ "x$t" = "xlist" ];then
			/usr/bin/gconftool-2 --direct --config-source="$configfile" --type list --set "$n" --list-type string "$v"
		else
			/usr/bin/gconftool-2 --direct --config-source="$configfile" --type "$t" --set "$n" "$v"
		fi
	fi
}

# Install schemas
gnome2_install_schema() {
	#this is this-is-deprecated
	#return 0
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/gconftool-2 ];then
		for schema in $schemas; do
			msg ">>> Installing: $schema"
			GCONF_CONFIG_SOURCE="$(gconftool-2 --get-default-source)" gconftool-2 --makefile-install-rule "$schema"  >/dev/null
		done
	fi
}

# Unstall schemas
gnome2_uninstall_schema() {
	#this is this-is-deprecated
	#return 0
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/gconftool-2 ];then
		for schema in $schemas; do
			msg ">>> Uninstalling: $schema"
			GCONF_CONFIG_SOURCE="$(gconftool-2 --get-default-source)" gconftool-2 --makefile-uninstall-rule "$schema"  >/dev/null
		done
	fi
}

# Install mine
gnome2_install_mine() {
	local mines="$@"
	if [ x"$mines" != x ] && [ -x /usr/bin/xdg-mime ];then
		for mine in $mines; do
			msg ">>> Installing: $mine"
			xdg-mime install --mode system "$mine"  >/dev/null
		done
	fi
}

# Unstall mine
gnome2_uninstall_mine() {
	local mines="$@"
	if [ x"$mines" != x ] && [ -x /usr/bin/xdg-mime ];then
		for mine in $mines; do
			msg ">>> Uninstalling: $mine"
			xdg-mime uninstall --mode system "$mine"  >/dev/null
		done
	fi
}

# Update rarian database
gnome2_rarian_sk_update() {
	if [ -x /usr/bin/rarian-sk-update ]; then
		msg ">>> Updating rarian database.."
		/usr/bin/rarian-sk-update
	fi
}

# Update desktop entries
gnome2_desktop_database_update() {
	if [ -x /usr/bin/update-desktop-database ]; then
		msg ">>> Updating desktop database.."
		/usr/bin/update-desktop-database
	fi
}

# Restart gconfd-2 if running to reload new gconf settings
gnome2_gconfd_reload() {
	if ps acx | grep -q gconfd-2; then
		msg ">>> Reloading gconfd settings.."
		killall -HUP gconfd-2
	fi
}

# Update gtk-immodules
gnome2_gtk_immodules_update() {
	if [ -x /usr/bin/update-gtk-immodules ]; then
		msg ">>> Updating gtk immodules.."
		update-gtk-immodules --verbose
        fi
}

# Update gdk pixbuf loaders
gnome2_gdk_pixbuf_loaders_update() {
	if [ -d /etc/gtk-2.0 ] && [ -x /usr/bin/update-gdk-pixbuf-loaders ]; then
		msg ">>> Updating gdk pixbuf loaders.."
		update-gdk-pixbuf-loaders
	fi
}

# Updates Gtk+ icon cache files under /usr/share/icons if the current pbs
# have installed anything under that location.
gnome2_icon_cache_update() {
	local dir=""
	#gnome2_icon_cache_update /usr/share/icons/titans|titans
	local updater="$(type -p gtk-update-icon-cache 2> /dev/null)"
	if [ "x$*" = "x" ]; then
		dir="/usr/share/icons/hicolor"
	else
		while [ "x$1" != "x" ]; do
			if [ ! -d "$1" ]; then
				dir+="/usr/share/icons/"$(basename $1)" "
			else	
				dir+="$1 "
			fi
			shift
		done
	fi
	msg ">>> Updating icons cache: $dir"
	"$updater" -f -q -t $dir
}

# Update mime database
gnome2_mime_database_update() {
	if [ -x /usr/bin/update-mime-database ]; then
		/usr/bin/update-mime-database /usr/share/mime/ 
	fi
}


#
# Install package
#

#
#fetch           break after download source tarball
#upack           break after unpack source tarball
#patch           break after patch source
#config          break after configure	
#build           break after make a.k.s compile
#check		 break after make check/test
#mkinstall         break after make install    
#package         break after make ypk package    

maybe_break() {
	local string="$1"
	local command="$(echo $@ |sed 's/'"$string"'//')"
	if echo "$BREAK" | egrep -q "(,|^)$string(,|$)"; then
		$command
		exit 1
	fi
}

#
# $1 - as follows:
# pkgname - lftp
# pkgtype/pkgname -net-ftp/lftp
# pbsfile - lftp_4.3.3.pbs 
#
ypkg_install() {
	local string="$1"
	local stat

	if ! ypkg_getpbsfile "$string"; then
		rmsg "[Error]: $string not found."
		return 1
	fi

	ypkg_searchInstalled $T $N $V$R >/dev/null
	
	local new=$V$R
	
	if [ "x$INSTALL_STATUS" = "xuninstall" ]; then
		stat="N"
	else
		atom_cmp $INSTALL_VERSION $new 
		case $? in
			1) stat="D"  ;;
	 		2) stat="U"  ;;
	 		0) stat="E"
		esac
	fi

	[ "x$FORCE_INSTALL" != "xyes" ] && gmsg_ "[$stat]" || gmsg_ "["$stat"F]"

	# N -- new install
	# U -- upgrade
	# D -- downgrade
	# E -- same version
	case $stat in
        	E) msg " $T/${N}_$V$R "	
		   [ "x$FORCE_INSTALL" != "xyes" ] && return 0         ;;
		N) msg " $T/${N}_$V$R "				       ;;
   	      U|D) msg " $T/${N}_$INSTALL_VERSION ----> $T/${N}_$V$R " 
	esac
		
	[ "x$PRETEND" = "xyes" ] && return 0
	
	ypkg_begin_download $NEWEST || return 1

	maybe_break fetch 

	#
	# Download ok, install it.
	#		
	
	workdir="$YPPATH_FIELD/$N"
	mkdir -p $workdir
	
	cd $workdir

	ymsg ">> $T/${N}_$V$R unpack"
	pbs_unpack
	err_check "* [Error]: $T/${N}_$V$R call pbs_unpack failed"

	maybe_break unpack pwd

	destdir="$workdir/${N}_$V$R"
	local pbsfile="$NEWEST"
	local pbsdir="${NEWEST%/*.pbs}"
	filesdir="${pbsdir}"/files
	buildlog="$pbsdir/${N}_$V$R-$YARCH.buildlog"

	local 	 patchpipe="$PWD/patch.pipe"
	local     patchlog="$PWD/patch-log"
	local 	 configpipe="$PWD/config.pipe"
	local     configlog="$PWD/configure-log"
	local      makepipe="$PWD/make.pipe"
	local       makelog="$PWD/make-log"
	local     checkpipe="$PWD/check.pipe"
	local      checklog="$PWD/check-log"
	local mkinstallpipe="$PWD/mkinstall.pipe"
	local  mkinstalllog="$PWD/mkinstall-log"

	srcdir="$PWD"

	cd "$N-$V$R" 2>/dev/null

	ymsg ">> $T/${N}_$V$R patch"
	[ -p $patchpipe ] || mkfifo $patchpipe
	tee $patchlog < $patchpipe & 
	pbs_patch > $patchpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_patch failed"

	maybe_break patch pwd

	ymsg ">> $T/${N}_$V$R configure"
	[ -p $configpipe ] || mkfifo $configpipe
	tee $configlog < $configpipe & 
	pbs_config > $configpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_config failed"

	maybe_break config pwd

	ymsg ">> $T/${N}_$V$R compile"
	[ -p $makepipe ] || mkfifo $makepipe
	tee $makelog < $makepipe & 
	pbs_build > $makepipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_build failed"

	maybe_break build pwd

	ymsg ">> $T/${N}_$V$R make check"
	[ -p $checkpipe ] || mkfifo $checkpipe
	tee $checklog < $checkpipe & 
	pbs_check > $checkpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_check failed"

	maybe_break check pwd

	ymsg ">> $T/${N}_$V$R make install"
	local packs=""
	local destdirs=($destdir)
	local descfiles=($descfiles)
	TT="$T"
	
	gene_desc() {
		local file=$1
        	cat >$file <<EOF
N="$N"
V="$V"
R="$R"
DESCRIPTION="$DESCRIPTION"
COMMENTS="$COMMENTS"
HOMEPAGE="$HOMEPAGE"
REPO="$REPO"
YARCH="$YARCH"
LICENSE="$LICENSE"
PRIORITY="$PRIORITY"
PACKAGER="$PACKAGER"
RDEPEND="$RDEPEND"
BDEPEND="$BDEPEND"
RECOMMENDED="$RECOMMENDED"
CONFLICT="$CONFLICT"
OPIONAL="$CONFLICT"
INSTALL="$INSTALL"
OPTIONS="$OPTIONS"
EOF
}
	gene_desc "$workdir"/base.desc 
	descfiles[0]=$(readlink -f "$workdir"/base.desc)
	
	[ -p $mkinstallpipe ] || mkfifo $mkinstallpipe
	tee $mkinstalllog < $mkinstallpipe & 
	pbs_install > $mkinstallpipe
	err_check "* [Error]: $T/${N}_$V$R call pbs_install failed"

	if [ "x$PROVIDE" != "x" ]; then	
		ymsg ">> $T/${N}_$V$R splite $PROVIDE."
		j=1

		for i in $PROVIDE; do
			. ${descfiles[0]}
			destdir="$workdir/${i}_$V$R"
			atom_parse $destdir
		
			ymsg ">> $TT/${N}_$V$R make install"
			${i}_install
			err_check "* [Error]: $TT/${N}_$V$R call ${N}_install failed"

			gene_desc $N.desc
			descfiles[$j]=$(readlink -f $N.desc)
			destdirs[$j]=$destdir
			blank_funcs
			let j=$j+1
		done

	fi

	>$buildlog
	[ -e $configlog ] && cat $configlog >> $buildlog
	[ -e $makelog ]   && cat $makelog >> $buildlog
	[ -e $checklog ]  && cat $checklog >> $buildlog
	[ -e $mkinstalllog ] && cat $mkinstalllog >> $buildlog
	[ -e $buildlog ]  && gzip -9 -f $buildlog

	maybe_break mkinstall pwd

	# make pkg package
	j=0
	for destdir in ${destdirs[@]}; do
		atom_parse $destdir
		ymsg ">> $TT/${N}_$V$R make package"
		. ${descfiles[$j]}
		packs+="$(ypkg_mkpackage $destdir) "
		err_check "* [Error]: $TT/${N}_$V$R make binary package failed"
		blank_funcs
		let j=$j+1
	done

	rm ${descfiles[@]}

	packs=$(echo $packs |tr ' ' '\n' |sort -u |xargs)

	maybe_break package "echo $packs"

	# install to system
	ymsg ">> $TT/${N}_$V$R $PROVIDE install to system"

	for pack in $packs; do
		case "x$AUTO_INSTALL" in
			xyes) mmsg ">>> Install: $pack"
			      ypkg -I -f $pack ;;
			   *) gmsg ">>> $pack"
		esac
	done

	[ -d $workdir ] && rm -r $workdir

	return 0
}

#
# $1 pkgname
# $2 notes/comments/depend/pbs
#
ypkg_show() {
	local ret
	local itype
	local iname
	local iver
	local irver
	ypkg_getpbsfile "$1"

	if [ $? == 0 ]; then
		atom_parse $NEWEST
		itype=$T
		iname="$N"
		iver=$V
		irver=$R
		. "$NEWEST"
		
		case $2 in
		notes)
			echo -e "$NOTES" ;;
		comments)
			echo -e "$COMMENTS" ;;
		depend)
			local pbsfile=${NEWEST##*/}
			msg_ ">> Dependencies of "
			wmsg "${pbsfile%*.pbs}:"
			gmsg "* Build_time"
			echo $BDEPEND |xargs
			gmsg "* Run_time"
			echo $RDEPEND |xargs
			gmsg "* Recommend"
			echo $RECOMMENDED |xargs
			gmsg "* Conflict"
			echo $CONFLICT |xargs ;;
		pbs)
			echo "$NEWEST"
		esac
	else
		rmsg "* [Error]: $1 not found!"
		return 1
	fi
}

#
#
ypkg_whatrequires() {
	local string="$1"
	local depend 
	local file
	ymsg "* "$string" is related with:"
	
	find "$YPPATH_LIB" -maxdepth 3 -type f -name "*.pbs" |while read file; do
		. "$file"
		for depend in RDEPEND BDEPEND RECOMMENDED CONFLICT; do
			if str_isIn "$(eval "echo \$${depend}")" "$string"; then
				case $depend in
				RDEPEND)
					gmsg_ "[R] "
					msg "$file"  ;;
				BDEPEND)
					ymsg_ "[B] "
					msg "$file"  ;;
			    RECOMMENDED) 
					bmsg_ "[A] "
					msg "$file"  ;;
			       CONFLICT)
					rmsg_ "[C] "
					rmsg "$file"
				esac
			fi
		done
		blank_funcs pbs
	done

	msg ""
}

#end of file
