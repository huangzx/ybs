#   Copyright © 2012 ivali.com
#   Maintainer: Zhongxin Huang <huangzhongxin@ivali.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

[ -e /etc/ybs.conf ] && . /etc/ybs.conf

## -------------------- colourful print --------------------
## ANSI Foreground color codes:
## 30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white 39=default
## ANSI Background color codes:
## 40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white 49=default
COLOR_RED=$(    echo -e "\e[31;49m" )
COLOR_GREEN=$(  echo -e "\e[32;49m" )
COLOR_YELLO=$(  echo -e "\e[33;49m" )
COLOR_BLUE=$(   echo -e "\e[34;49m" )
COLOR_MAGENTA=$(echo -e "\e[35;49m" )
COLOR_CYAN=$(   echo -e "\e[36;49m" )
COLOR_WHILE=$(   echo -e "\033[1m" )
COLOR_RESET=$(  echo -e "\e[0m"     )
      
# Msg argv: "$str"
msg()  { echo "$@";                               }
rmsg() { echo "${COLOR_RED}$*${COLOR_RESET}";     }
gmsg() { echo "${COLOR_GREEN}$*${COLOR_RESET}";   }
ymsg() { echo "${COLOR_YELLO}$*${COLOR_RESET}";   }
bmsg() { echo "${COLOR_BLUE}$*${COLOR_RESET}";    }
mmsg() { echo "${COLOR_MAGENTA}$*${COLOR_RESET}"; }
cmsg() { echo "${COLOR_CYAN}$*${COLOR_RESET}";    }
wmsg() { echo "${COLOR_WHILE}$*${COLOR_RESET}";   }
					
# Colourful print without "\n"
msg_()  {  msg "$@" | tr -d '\n'; }
rmsg_() { rmsg "$@" | tr -d '\n'; }
gmsg_() { gmsg "$@" | tr -d '\n'; }
ymsg_() { ymsg "$@" | tr -d '\n'; }
bmsg_() { bmsg "$@" | tr -d '\n'; }
mmsg_() { mmsg "$@" | tr -d '\n'; }
cmsg_() { cmsg "$@" | tr -d '\n'; }
wmsg_() { wmsg "$@" | tr -d '\n'; }

# PATH defines
YBS_PATH="/var/ybs"
[ "x$PBSLIB_URI" = "x" ] && PBSLIB_URI="git://git.ylmf.com/pbslib.git"
[ "x$PBSLIB_PATH" = "x" ] && PBSLIB_PATH="$YBS_PATH/pbslib"
[ "x$PBSLIB_BRANCH" = "x" ] && PBSLIB_BRANCH="startos-5.x"
YBS_SOURCE="$YBS_PATH/sources"
PBSLIB_SCRIPT="$PBSLIB_PATH"
[ "x$WORKING_FIELD" = "x" ] && WORKING_FIELD="/var/tmp/ybs"
PACKAGE_DB="/var/ypkg/db/package.db"
SQLITE="$(which sqlite3)"
[ "x$YPK_DEST" = "x" ] && YPK_DEST="$YBS_PATH/packages"
PACK_SUFFIX="ypk"
CPIO="/bin/cpio"
#CPIO="/usr/bin/bsdcpio"
XZ="/usr/bin/xz"
CHECK_TOOLS="md5sum sha1sum sha256sum"

# Strip para
[ "x$STRIP_BINARIES" = "x" ] && STRIP_BINARIES="--strip-all"
[ "x$STRIP_SHARED" = "x" ]  && STRIP_SHARED="--strip-unneeded"
[ "x$STRIP_STATIC" = "x" ] && STRIP_STATIC="--strip-debug"

# Upx para
[ "x$UPXFLAGS" = "x" ] && UPXFLAGS="-9"

# Ccache para
[ "x$CCACHE_DIR" = "x" ] && CCACHE_DIR="$WORKING_FIELD/.ccache"
[ "x$CCACHE_SIZE" = "x" ] && CCACHE_SIZE="5G"

# Distcc para
[ "x$DISTCC_HOSTS" = "x" ] && DISTCC_HOSTS=""

# Make para
[ "x$MAKEOPTS" = "x" ] && MAKEOPTS="-j3"

# Repo channel
[ "x$ACCEPT_REPO" = "x" ] && ACCEPT_REPO="stable"

# Download tool
[ "x$DOWNLOAD_TOOL" = "x" ] && DOWNLOAD_TOOL="wget"
[ "x$WGET_OPTIONS" = "x" ] && WGET_OPTIONS="--tries=3 --retry-connrefused --wait=2"
[ "x$CURL_OPTIONS" = "x" ] && CURL_OPTIONS="-L"

# Source uri
[ "x$SOURCE_URI" = "x" ] && SOURCE_URI="http://pkg.startos.org/sources"

# Install ypk after building
[ "x$AUTO_INSTALL" = "x" ] && AUTO_INSTALL="no"

# Get system arch
get_arch() {
	DIST_INFO=($(cat /var/ypkg/modules/kernel))
	KERNEL_DIST=${DIST_INFO[0]}
	ARCH_DIST=${DIST_INFO[1]}
	KERNEL_RUNNING="$(uname -r)"
	ARCH_RUNNING="$(uname -m)"
	[ "x$ARCH" = "x" ] && ARCH=$ARCH_DIST
	[ "x$ARCH" = "x" ] && ARCH=$ARCH_RUNNING

	case "$ARCH" in
		i?86) ARCH=i686 ;;
		arm*) ARCH=arm ;;
		   *) ARCH="$ARCH" ;;
	esac

	[ "x$YARCH" = "x" ] && YARCH="$ARCH"
	[ "x$YARCH" = "xany" ] && YARCH="$ARCH"
	export ARCH 
	export YARCH
	echo $YARCH
}

get_arch >/dev/null

[ "x$CC" = "x" ] && CC=gcc
[ "x$CXX" = "x" ] && CXX=g++
LIBDIRSUFFIX=""

case "$ARCH" in
	"i686")	[ "x$CFLAGS" = "x" ] && CFLAGS="-O2 -march=i686 -mtune=i686 -pipe " ;;	
	"s390")	[ "x$CFLAGS" = "x" ] && CFLAGS="-O2 "   ;;
      "x86_64") 
		[ "x$CFLAGS" = "x" ] && CFLAGS="-O2 -fPIC "
		LIBDIRSUFFIX="64"
		CC="$CC -m64"
		CXX="$CXX -m64"
		;;
	     *)	[ "x$CFLAGS" = "x" ] && CFLAGS="-O2 "   
esac

[ "x$CXXFLAGS" = "x" ] && CXXFLAGS="$CFLAGS "

export CC
export CXX
export CFLAGS
export CXXFLAGS
export LIBDIRSUFFIX
export YPK_DEST
export MAKEOPTS
export ACCEPT_REPO
export SOURCE_URI
export AUTO_INSTALL
export DOWNLOAD_TOOL
export CURL_OPTIONS
export WGET_OPTIONS
export FEATURES
export CCACHE_DIR
export CCACHE_SIZE
export DISTCC_HOSTS
export STRIP_BINARIES
export STRIP_SHARED
export STRIP_STATIC
export UPXFLAGS

DEFAULT_CONFIG="--prefix=/usr
		        --sysconfdir=/etc
		        --libdir=/usr/lib"$LIBDIRSUFFIX"
		        --libexecdir=/usr/libexec
		        --localstatedir=/var
		        --infodir=/usr/share/info
		        --mandir=/usr/share/man
		        --enable-shared "
PKG_CONFIG_PATH=/usr/lib"$LIBDIRSUFFIX"/pkgconfig

pkgdata="pkgdata"
pkginfo="pkginfo"
control="control.xml"
filelist="filelist"

# Check required app
check_required_bin() {
	local ccache
	if str_isIn "$FEATURES" "ccache"; then
		if ! which ccache >/dev/null 2>/dev/null; then 
			die "Feature: ccache is enabled in ybs.conf. Please install ccache."		
		fi
	fi
	
	local distcc
	if str_isIn "$FEATURES" "distcc"; then
		if ! which distcc >/dev/null 2>/dev/null; then
			die "Feature: distcc is enabled in ybs.conf. Please install distcc."
		fi
	fi
	
	local upx
	if str_isIn "$FEATURES" "upx"; then
		if ! which upx >/dev/null 2>/dev/null; then
			die "Feature: upx is enabled in ybs.conf. Please install upx."
		fi
	fi

	local strip
	if str_isIn "$FEATURES" "strip"; then
		if ! which strip >/dev/null 2>/dev/null; then
			die "Feature: strip is enabled in ybs.conf. Please install binutils."
		fi
	fi
	
	local xz
	if ! which xz >/dev/null 2>/dev/null; then
		die "xz is required, please install xz-utils."
	fi
	
	local i
	if ! which $DOWNLOAD_TOOL >/dev/null 2>/dev/null; then
		die "$DOWNLOAD_TOOL is enabled in ybs.conf. Please install $DOWNLOAD_TOOL"
	fi
}

blank_funcs () {
	DESCRIPTION=""
	COMMENTS=""
	HOMEPAGE=""
	REPO=""
	YARCH="$(get_arch)"
	LICENSE=""
	PRIORITY=""
	GROUP=""
	PACKAGER=""
	SRC_URI=""
	CHECKSUM=""
	RDEPEND=""
	BDEPEND=""
	RECOMMENDED=""
	CONFLICT=""
	REPLACE=""
	NOTES=""
	OPIONAL=""
	PROVIDE=""
	INSTALL=""
	OPTIONS=""
	RIR=""
	ALIAS=""
	
	INAME=""
	CATEGORY=""
	VERSION=""
	TYPE=""
	INSTALL_SIZE=""
	BUILD_TIME=""
	BIN_URI=""
	PACK_SIZE=""
	SHA=""
	NAME=""
	if [ "x$1" = "xpbs" ];then
		pbs_unpack() { :
		}
		pbs_patch() { :
		}
		pbs_config() { : 
		}
		pbs_build() { : 
		}
		pbs_check() { : 
		}
		pbs_install() { : 
		}
	fi
	[ "x$1" = "xdesc" ] && :
}

file_is_exist () {
	[ -f "$1" ] && return 0 || return 1
}

check_root () {
	if [ "x$UID" != "x0" ];then
	        rmsg "You must be root to run this script."
        	ymsg "Try: sudo $0 $*"
       		exit 1
	fi
}

summation() {
	if [ "x$1" = "x" ];then
		msg "summation: you must specify a list of digit"
		msg "i.e. 'summation 1 2 3' "
		return 1
	fi
        
	local sum=0
	
	while [ "x$1" != "x" ]; do
		local tmp=$1
		let "sum=sum+tmp"
		shift
	done
	
	echo $sum
	return 0
}

get_abspath () {
	local file="$1"
	
	if [ ! -h "$file" ]; then
		file=$(readlink -f "$file")
	else
		file=$(cd $(dirname $file) 2>/dev/null; pwd)/${file##*/}
	fi

	echo "$file"
}

#
# If $2 in $1 return 0, else return 1
#
str_isIn() {
        if [ "x$2" = "x" ];then
		msg "str_isIn: you must specify at least two strings."
	        msg "i.e. 'str_isIn \"a b c\" b'"
		return 1
	fi
	
	local string=($1)
	local substring="$2"

	for i in ${string[@]}; do
		[ "x$i" = "x$substring" ] && return 0
	done

	return 1
}

err_check() {
	if [ $? != 0 ]; then
		rmsg "$1"
		exit 1
	fi
}

die() {
	rmsg ":( $@"
	exit 1
}

warn() {
	ymsg "$@"
}

atom_parse() {
	T=""
	N=""
	V=""
	R=""
	PBSDIR=""
	local atom
	local string="$1"

	if [ "x${string##*.}" = "xpbs" ]; then
		local pbsfile="$(readlink -f $string)"
		if [ -f "$pbsfile" ]; then
			PBSDIR="${pbsfile%/*.pbs}"
			# filesdir contains patchs and user-defined files 
			filesdir="$PBSDIR"/files/
		fi
	fi

	if echo "$string" |grep -q "/"; then
		# /var/ybs/pbslib/net-ftp/lftp/lftp_4.3.3.pbs
		if echo "$string" |grep -q "$PBSLIB_PATH"; then
			atom=${string##*/}
			T=${string%/*}
			T=${T%/*}
			T=${T##*/}
			string="$atom"
		fi
	
		# net-ftp/lftp_4.3.3.pbs
		if echo "$string" |grep ^[a-z] |grep -q "/"; then
			T=${string%%/*}
			atom=${string##$T/}
			string=$atom
		fi
		[ "x$atom" = "x" ] && string=${string##*/}
	fi

	case x${string##*.} in
		xpbs)           
 	  atom="${string%.pbs}" ;;
		x$PACK_SUFFIX)     
	  atom="${string%.$PACK_SUFFIX}" ;;
		xfilelist)	
	  atom="${string%.filelist}" ;;
		xdesc)	
	  atom="${string%.desc}" ;;
	  	xxml)
	  atom="${string%.xml}" ;;
		*)      
 	  atom="$string"
	esac

	# Only digit
	if [ "x$(echo $atom |tr -d '[:digit:]' |tr -d '.' |tr -d '-')" = "x" ]; then
		atom=foo_$atom
	fi

	#XXX, it is hard-coded here
	atom=${atom%-i686}
	atom=${atom%-x86_64}
	atom=${atom%-any}

	# cairo(>=1.6) x11-libs/cairo(>=1.6)
	if echo $atom |grep \( |grep -q \); then
		N=${atom%%(*)}
		VR="${atom##$N}"
		VR=$(echo $VR |tr -d '[:blank:]')
		return 0
	fi

	N=${atom%%_[0-9]*}
	N=${N%%_}
	VR=${atom#$N}
	VR=${VR#_}
	#V=${VR%%-[a-zA-z]*}
	V=${VR%%-*}
	R=${VR##$V}
}

#
# Compare 2 atoms
# 1、linux_2.6.9.pbs and linux_2.6.10.pbs
# 2、2.6.9 2.6.10
# 3、/var/ybs/pbslib/app-editors/leafpad/leafpad_0.8.17.pbs /var/ybs/pbslib/app-editors/leafpad/leafpad_0.8.18.pbs
# 4、1.2.3 3.2.1
# the former > the latter, return 1
# the former < the latter, return 2
# the former = the latter, return 0
# alpha < beta < rc < ylmf < r

string_len() {
	local string=$1
	local sep=$2
	local i
  	if [ "x$sep" = "x" ]; then
		i=($(echo $string |awk '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	else
	        i=($(echo $string |awk -F$sep '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	fi  
        echo ${#i[@]}
}

atom_cmp() {
    local string1="$1"
	local string2="$2"
	local v1 v2
	
	string1=${string1#*_}
	v1=${string1%.[A-Za-z][A-Za-z][A-Za-z]}
	v1=${v1%-$YARCH}
	v1=$(echo $v1 |tr '[A-Z]' '[a-z]')

	string2=${string2#*_}
	v2=${string2%.%.[A-Za-z][A-Za-z][A-Za-z]}
	v2=${v2%-$YARCH}
	v2=$(echo $v2 |tr '[A-Z]' '[a-z]')
    
	if [ "x$v1" = "x$v2" ] || test $v1 -eq $v2 2>/dev/null;then
		return 0
	fi

	# seperator is -
	local v1=($(echo $v1 |awk -F- '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	local v2=($(echo $v2 |awk -F- '{print $1" "$2" "$3" "$4" "$6" "$7}'))
	[ "1${#v1[@]}" -lt "1${#v2[@]}" ] && maxnum=${#v2[@]} || maxnum=${#v1[@]}

	for ((i=0; i<maxnum; i++)); do
		a=${v1[i]}.
		b=${v2[i]}.
		# seperator is dot .
		a_len=$(string_len $a .)
		b_len=$(string_len $b .)
		[ "$a_len" -lt "$b_len" ] && max=$b_len || max=$a_len

		for ((j=0; j<max; j++)); do
			c=${a%%.*}
			d=${b%%.*}

			coa=$(echo $c |tr -d '[:digit:]' |tr -d '[:punct:]')
			doa=$(echo $d |tr -d '[:digit:]' |tr -d '[:punct:]')
			cod=$(echo $c |tr -d '[:alpha:]' |tr -d '[:punct:]')
			dod=$(echo $d |tr -d '[:alpha:]' |tr -d '[:punct:]')

			coa=${coa:-n}
			doa=${doa:-n}
			cod=${cod:-0}
			dod=${dod:-0}

			if [ "x$coa" = "x$doa" ]; then
				[ $cod -gt $dod ] && return 1
				[ $cod -lt $dod ] && return 2
			else
				case $coa$doa in
					rcn|betan|alphan) return 2 ;;
				        nrc|nbeta|nalpha) return 1 ;;
				                   ylmfn) return 1 ;;
				                   rn)    return 1 ;;
				                   nylmf) return 2 ;;
				                   nr)    return 2 ;;
						 rylmf)   return 1 ;;
				          rcbeta|rcalpha) return 1 ;;
				                  betarc) return 2 ;;
				               betaalpha) return 1 ;;
				       alpharc|alphabeta) return 2 ;;
			       rcylmf|betaylmf|alphaylmf) return 2 ;;
			       rcr|betar|alphar|ylmfr)    return 2 ;;
			       esac
			 fi
			 a=${a#*.}
			 b=${b#*.}
		done
	done

	return 0
}

#
# $1 $T 
# $2 $N
# $3 $V$R (this is the newest version) 
#
ybs_searchInstalled() {
	local pkgtype=$1
	local pkgname=$2
	local pkgver=$3

	local info=$($SQLITE $PACKAGE_DB "select name,version,repo,install_time from world where name='$pkgname'")

    # Try find provide name
    if [ "x$info" = "x" ]; then
	    info=$($SQLITE $PACKAGE_DB "select name,version,repo,install_time from world where name='${PROVIDE_NAME}'")
    fi
    PROVIDE_NAME=
	case "x$info" in
		x) 
			msg_ "[*] "
			echo "$(wmsg $pkgtype/$pkgname)"
	   		echo -e "\t$(gmsg "Installed:") None"
	  		INSTALL_STATUS="uninstall" ;;

	 	x*)
			info=(${info//|/ })
			INSTALL_VERSION=${info[1]}
			INSTALL_TIME=${info[3]}
			INSTALL_TIME=$(date -d "1970-01-01 UTC $INSTALL_TIME seconds" +%F,%T)
			new=$pkgver
			old=$INSTALL_VERSION
			# Compare 2 versions
			# Return 0 if same.
			# Return 1 if $1 is grater than $2
			# Return 2 if $1 is lesser then $2
	       		atom_cmp $old $new
			case $? in
				1) 
				   INSTALL_STATUS="downgrade"
				   gmsg_ "[D] "  ;;
			        2) 
				   INSTALL_STATUS="upgrade"
				   gmsg_ "[U] " ;; 
				0) 
				   INSTALL_STATUS="installed"
				   gmsg_ "[I] "
			esac 
			echo "$(wmsg $pkgtype/$pkgname)"
			echo -e "\t$(gmsg Installed:) $(ymsg $INSTALL_VERSION) $INSTALL_TIME" ;;
	esac
}

ybs_search() {
	local string="$1"
	local pbsfile
	local record=""

	if ! ybs_getpbsfile "$string" all; then
		rmsg ":( $string not found."
		return 1
	fi
	
	for pbsfile in $ALL_PBSFILE; do
		atom_parse "$pbsfile"
		
		str_isIn "$record" "$T/$N" && continue
		record+="$T/$N "
		
		ybs_getpbsfile $T/$N name
		
		ybs_searchInstalled $T $N $V$R

		msg=""
		for pbsfile in $ALL_PBSFILE; do
			REPO=""
			atom_parse $pbsfile
			. $pbsfile
			case $REPO in
				[Tt]esting) repo="t"  ;;
	                  	 [Ss]table) repo="s" ;;
	               	       [Uu]nusable) repo="u" ;;
	                                 *) repo="s"
	                 esac
	                 msg+="$(mmsg $V$R[$repo]) | "
		done

		echo -e "\t$(gmsg "Available:") $msg"
		. $NEWEST
		echo -e "\t$(gmsg "Homepage:") $HOMEPAGE"
		echo -e "\t$(gmsg "Description:") $DESCRIPTION"
		echo 

		blank_funcs
	done
}

#
# Download packeage
#
do_download () {
	local uri="$1"
	local fname="$2"
	local target="$YBS_SOURCE/$fname.tmp"
	
	local wget="wget $WGET_OPTIONS"
	local curl="curl $CURL_OPTIONS"

	msg "Downloading: ${uri}"

	# uri is file:///foo and foo is file
	if [ "x${uri%%:*}" = "xfile" ]; then
		[ -f "${uri##file:/}" ] && cp "${uri##file:/}" "$target" && return 0
	fi
	
	case $DOWNLOAD_TOOL in
		curl)
			$curl $uri -o "$target" || return 1
			grep -q "404 Not Found" "$target" && return 1 || return 0 ;;
  	      wget|*)
			if [ "x$(echo $uri |cut -c 1-5)" == "xhttps" ];then	
				$wget --no-check-certificate $uri -O "$target" && return 0
			else
				$wget $uri -O "$target" && return 0
			fi	
	esac

	return 1
}

#
# Check and download package
# $1 is URL
# $2 is local file name
# $3 is checksum value, md5sum/sha1sum/sha256sum, default is md5sum
#
check_and_download_raw() {
	local uri="$1"
	local fname="$2"
	local checksum="$3"
	local download
	local checkok
	local target="${YBS_SOURCE}/${fname%.git}"
	
	msg "From: $uri - To: $target"

	case ${uri%%:*} in
	  svn)
		cd ${YBS_SOURCE}
		local name="$N"
		cd "$name" && svn update || svn checkout "${uri}" "$N" 
		;;

	  git)	
		local name="$N"
		cd ${YBS_SOURCE}
		if [ ! -d "$name" ];then 
			rm "$name" 2>/dev/null
			git clone "${uri}" "$name" && return 0
		fi
		if [ -d "$name"/.git ]; then
			olduri=$(grep "url =" $name/.git/config 2>/dev/null |sed 's/\	url\ =\ //g')
			if [ "x$olduri" = "x$uri" ]; then
				cd "$name" && git pull && return 0
			else
				rm -rf "$name"
				git clone "${uri}" "$name" && return 0
			fi	
		fi 
		;;

    http|https|ftp|file|*)	
		local checksum_server="$checksum"

		# url is file:///foo and foo is dir
		if [ "x${uri%%:*}" = "xfile" ]; then 
			local file=$(readlink -f ${url##file:/})
			if [ -d "$file" ]; then
				if cp -a "$file" "${YBS_SOURCE}"; then
					gmsg "Rename: $target"
					return 0
				fi
			else
				[ -f "$file" ] || return 1
			fi
		fi

		# target is exists and checksum_server is empty or checksum correct
		if [ -f "$target" ]; then
			if [ "x$checksum_server" = "x" ]; then
				msg "$target exists without checksum." 
				return 0
			fi
			
			for checktool in $CHECK_TOOLS; do
				checksum_local=($($checktool "$target" 2>/dev/null))
				checksum_local="${checksum_local[0]}"
				if [ "x$checksum_local" = "x$checksum_server" ]; then
					msg "$target exists and $checktool checked correctly." 
					return 0
				fi
			done
		fi

		# target is not exists or checksum fail 
		if [ -f "$target" ] || [ "x$checkok" != "xyes" ]; then
			rm -f "$target".tmp 2>/dev/null

			if do_download $uri $fname; then
				download="done"
			else
				# Try ylmfos dist source
				uri="$SOURCE_URI/${fname}"
				do_download $uri $fname && download="done" || download="error"
			fi

			if [ "x$download" = "xdone" ]; then
				# Check again
				for checktool in $CHECK_TOOLS; do
					checksum_local=($($checktool "$target".tmp 2>/dev/null))
					checksum_local="${checksum_local[0]}"
					if [ "x$checksum_local" = "x$checksum_server" ] || [ "x$checksum_server" = "x" ]; then
						gmsg "Rename: $target"
						gmsg "$checktool: $checksum_local"
						checkok="yes"
						mv "$target".tmp "$target" 
						return 0
					else
						continue	
					fi
				done

				if [ "x$checkok" != "x$yes" ] ;then
					rmsg ""$target".tmp download successfully but $checktool checked failed."				
				        return 1
				fi
			fi
		fi
	esac

	return 1
}

#
# $1 - strings
# $2 - all OR name
# resules:
# $ALL_PBSFILE : all version pbs files with absolutive path 
# $NEWEST: newest or specifid version pbs files with absolutive path
# 
ybs_getpbsfile() {
	NEWEST=""	
	local files_ready
	local files_ready_raw
	local string="$1"
	local range="$2"
	local min
	local max
	local iname
	
	atom_parse "$1"
	local find_dir="${PBSDIR}"
	[ "x$find_dir" = "x" ] && find_dir=$PBSLIB_PATH	

	if [ "x$N" == "x" ]; then
		echo "No package specified."
		return 1
	fi

	local count=0
	if [ "x$find_dir" = "x$PBSLIB_PATH" ]; then
		local dir=$(find $find_dir/$T -maxdepth 2 -type d -iname "$N")
		for pack in $dir; do let "count++"; done
		
		if [ "$count"0 -gt 10 ]; then
			rmsg "Too more results: "
		        echo $dir
		        return 1
		fi
	fi

	VR="$(echo $VR |tr -d '()')"
	
	case $range in
		all)   iname="*${N}*.pbs" ;;
	       name|*) iname="${N}_*.pbs"
	esac


	local pbsfiles=($(find $find_dir/"$T" -maxdepth 3 -type f -iname "$iname" |sort -u))
	
	if [ "x$pbsfiles" = "x" ]; then
		# Fixme!
		# find provide
		pbsfiles=($(find $find_dir/"$T" -maxdepth 3 -type f -iname "*.pbs" |sort -u |xargs grep PROVIDE  |grep -w "$N" |awk -F: '{print $1}'))
        PROVIDE_NAME="$N"
	fi	

	[ "x$pbsfiles" = "x" ] && return 1

	case $range in
		all)  ALL_PBSFILE="${pbsfiles[@]}"
		      return 0 ;;
		name) ALL_PBSFILE="${pbsfiles[@]}"
	esac
	
	case x$VR in
		x\>[[:digit:]]*)	
        		min=${VR#>} 
			for file in ${pbsfiles[@]}; do
	        		atom_cmp $min $file
				[ $? -eq 2 ] && files_ready+="$file "
			done	;;

		x\>\=[[:digit:]]*) 
        		min=${VR#>=} 
			for file in ${pbsfiles[@]}; do
	        		atom_cmp $min $file
				[ $? -ne 1 ] && files_ready+="$file "
			done	;;
			
		x\<[[:digit:]]*)	 
			max=${VR#<}
			for file in ${pbsfiles[@]}; do
				atom_cmp $max $file
				[ $? -eq 1 ] && files_ready+="$file "
			done ;;

		x\<\=[[:digit:]]*)
			max=${VR#<=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $max $file
				[ $? -ne 2 ] && files_ready+="$file "
			done ;;

		x\!\=[[:digit:]]*) 
			min=${VR#!=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				[ $? -ne 0 ] && files_ready+="$file "
			done ;;

		x\=[[:digit:]]*)	
		        min=${VR#=}
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				[ $? -eq 0 ] && files_ready+="$file "
			done	;;

			*)
			min=${VR}	
			for file in ${pbsfiles[@]}; do
				atom_cmp $min $file
				if [ $? -eq 0 ]; then
					NEWEST="$file"
					atom_parse $NEWEST
					return 0
				else	
					files_ready+="$file "
				fi
			done
	esac

	[ "x$files_ready" = "x" ] && return 1 || files_ready=($files_ready)

	for file in ${files_ready[@]}; do
		blank_funcs pbs
		. $file
		case $REPO in
			[Tt]esting)  
		  [ "x$ACCEPT_REPO" = "xtesting" ] && files_ready_raw+="$file " || continue  ;;
		         *)
		  files_ready_raw+="$file "
		esac
	done

	files_ready_raw=($files_ready_raw)
	NEWEST=${files_ready_raw[0]}	

	for file in ${files_ready_raw[@]}; do
		atom_cmp $file $NEWEST
		[ "$?" == "1" ] && NEWEST=$file
	done
	
	if [ "x$NEWEST" != "x" ]; then
		atom_parse $NEWEST
		return 0
	fi

	return 1
}

#
# $1 - pbsfile with abspath, such as NEWEST
#
ybs_begin_download() {
	local url
	local pbsfile="$1"

	ymsg ">> $T/${N}_$V$R begin download."

	blank_funcs pbs

	config=$DEFAULT_CONFIG
	export PKG_CONFIG_PATH

	PBSLIB_SCRIPT="$PBSLIB_PATH/$T/$N"

	if [ -f "$pbsfile" ];then
		. $pbsfile
		err_check ":( $pbsfile is invalid! "
	else
		err_check ":( $1pbsfile not found"
	fi

	mkdir -p $YBS_SOURCE
	err_check ":( Create dir $YBS_SOURCE failed."

	# download all files
	if [ "x${SRC_URI}" != "x" ]; then
		local count=0
		local checksum=""

		# CHECKSUM: $SRC_URI in pbs file has md5sum/sha1sum/sha256sum value one by one.
		checksum=($CHECKSUM)
		
		for url in ${SRC_URI}; do
			# url localfile checksum
			check_and_download_raw $url ${url##*/} ${checksum[$count]}
			err_check ":( Download $url failed."
			let count=count+1
		done
	fi

	return 0
}

ybs_download() {
	local string="$1"
	ybs_getpbsfile "$string"

	if [ "$?" == "0" ]; then
		# found, download it
		ybs_begin_download $NEWEST
		return 0
	fi

	rmsg ":( $string not found."
	return 1
}


#
# Strip unrequested i18n in path $1
#
ybs_strip_i18n() {
	local ipath="$1/usr/share/locale"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns; do
		name=${i##*/}
		str_isIn "$LANGUAGE" $name 
		if [ "$?" == "1" ]; then
			# not in LANGUAGE, remove.
			rm -rf $ipath/$name
		fi
	done
}

#
# Strip unrequested i18n in man path.
#
ybs_strip_mani18n() {
	local ipath="$1/usr/share/man"
	local i18ns=$(ls $ipath 2>/dev/null)
	local name

	for i in $i18ns; do
		name=${i##*/}

		# skip man1 -- man9
		str_isIn "$name" "man"
		if [ "$?" == "1" ]; then
			continue
		fi

		str_isIn "$LANGUAGE" $name 
		if [ "$?" == "1" ]; then
			# not in LANGUAGE, remove.
			rm -rf $ipath/$name
		fi
	done
}

#
# Upx for compressing executables files
#
ybs_upx_bin () {
	local dir="$1"
	local binary

	find $dir -type f -perm -u+w 2>/dev/null | while read binary ; do
		if [[ $(file -bi "$binary") = *'application/x-executable'* ]]; then
			if ! upx $UPXFLAGS "$binary" >/dev/null 2>&1; then
				 [ -f $binary.upx ] && rm -rf $binary.upx
			fi
                 fi
	done
}

#
# Removing libtool files...
#
ybs_rm_libtool () {
	local dir="$1"
	find $dir ! -type d -name "*.la" -exec rm -f -- '{}' \;
}

#
# Strip binary in directory $1
#
ybs_strip_bin() {
	[[ -z ${STRIP_SHARED+x} ]] && STRIP_SHARED="-S"
	[[ -z ${STRIP_STATIC+x} ]] && STRIP_STATIC="-S"

	local dir="$1"
	local binary
	
	find $dir -type f -perm -u+w 2>/dev/null | while read binary ; do
		case "$(file -bi "$binary")" in
			*application/x-sharedlib*)  # Libraries (.so)
				strip $STRIP_SHARED "$binary" 2>/dev/null ;;
			*application/x-archive*)    # Libraries (.a)
				strip $STRIP_STATIC "$binary" 2>/dev/null ;;
			*application/x-executable*) # Binaries
				strip $STRIP_BINARIES "$binary" 2>/dev/null ;;
		esac
	done
}

#
# Compress man doc and info 
#
ybs_gzip_extra() {
	local dir="$1"
	rm "$dir"/usr/share/info/dir 2>/dev/null
	find "$dir"/usr/{,share/}{man,doc,info} -type f -exec gzip -9 -f '{}' ';' 2>/dev/null
}

#
# System Xorg Desktop Utilities Network Games Graphics Video             
# Audio Office Development Security Science-education Drivers
# Multimedia Misc Non-free
#
ybs_get_category() {
	local type category desktop
	type="$1"
	desktop="$2"

	if [ "x$desktop" != "x" ] && [ -f "$desktop" ]; then
		egrep -q "(=|;)AudioVideo" "$desktop" && echo Multimedia && return
		egrep -q "(=|;)Office"     "$desktop" && echo Office && return
		if egrep -q "(=|;)Network" "$desktop"; then
			egrep -q "(=|;)InstantMessaging" "$desktop" && echo IM && return
			echo Network && return
		fi
		if egrep -q "(=|;)Education" "$desktop" || egrep -q "(=|;)Science" "$desktop"; then
			echo Science-education && return
		fi
		egrep -q "(=|;)Game" "$desktop" && echo Games && return
		egrep -q "(=|;)Graphics" "$desktop" && echo Graphics && return
		egrep -q "(=|;)Development" "$desktop" && echo Development && return
		if egrep -q "(=|;)Utility" "$desktop" || egrep -q "(=|;)System" "$desktop"; then
			echo Utilities && return
		fi
	else	
		case ${type%%-*} in
		sys|x11|gnome|app)
			        category="Utilities"          ;;
	       www|net|mail)	category="Network"	      ;;
       			 im)    category="IM"		      ;;
    		      games)	category="Games" 	      ;;
    		   graphics)	category="Graphics" 	      ;;
    		      media)	category="Multimedia" 	      ;;
 	    printer|office)	category="Office" 	      ;;
 	   	        dev)	category="Development" 	      ;;
 	   	   security)	category="Security" 	      ;;
		    drivers)    category="Drivers"	      ;;
	      education|sci)	category="Science-education"  ;;
			non)	category="Non-free"	      ;;
	    	      misc|*)	category="Misc"               
		esac
		echo $category && return
	fi
	echo Misc
}

split_dev() {
	local dir="$1"
	local destdir="$workdir"
	
	rm -rf "$destdir"/"$N-dev_$V$R" 2>/dev/null

	#/usr/include  /usr/share/include
	if [ -d "$dir"/usr/include ]; then
		rm -rf "$destdir"/"$N-dev_$V$R"/usr/include 2>/dev/null
		domv "$dir"/usr/include "$destdir"/"$N-dev_$V$R"/usr/
	fi

	if [ -d "$dir"/usr/share/include ]; then
		rm -rf "$destdir"/"$N-dev_$V$R"/usr/share/include 2>/dev/null
		domv "$dir"/usr/share/include "$destdir"/"$N-dev_$V$R"/usr/share/
	fi

	# *.la *.a *.h *.hpp
	devlib=$(find $dir/ -type f -name "*.la" -o -name "*.a" 2>/dev/null)
	devlib+=" $(find $dir/ -type f -name "*.h" -o -name "*.hpp" 2>/dev/null |grep "/include/")"
	
	if [ x"$devlib" != "x" ]; then
		for lib in $devlib; do
			i=${lib#$dir}
			libdir=${i%/*}
			domv $lib  $destdir/$N-dev_$V$R/$libdir
			rmdir -p ${lib%/*} 2>/dev/null
		done
	fi

	# pkgconfig
	pcdir=$(find $dir -type d -name "pkgconfig" 2>/dev/null)
	
	if [ x"$pcdir" != "x" ]; then
		for pc in $pcdir; do
			i=${pc#$dir}
			dirpc=${i%/*}
			rm -rf "$destdir"/"$N-dev_$V$R"/"$dirpc"/pkgconfig 2>/dev/null
			domv $pc $destdir/$N-dev_$V$R/$dirpc
			rmdir -p ${pc%/*} 2>/dev/null
		done
	fi
	
	# /usr/share/aclocal/ogg.m4
	acls=$(ls -d $dir/usr/share/aclocal/* $dir/usr/share/aclocal-*/* 2>/dev/null)
	
	if [ x"$acls" != "x" ]; then
		rm -rf "destdir"/"$N-dev_$V$R"/usr/share/{aclocal,aclocal-*} 2>/dev/null
		for acl in $acls; do
			i=${acl#$dir}
			acldir=${i%/*}
			domv "${acl}" $destdir/$N-dev_$V$R/"${acldir}"
			rmdir -p "${acl%/*}" 2>/dev/null
		done
	fi
	
	[ -d $destdir/$N-dev_$V$R ] && echo $destdir/$N-dev_$V$R && return 0
	
	return 1
}

split_doc() {
	local dir="$1"
	local destdir="$workdir"
	docs=$(ls -d $dir/usr/share/doc/* 2>/dev/null)
	gtk_docs=$(ls -d $dir/usr/share/gtk-doc/html/* 2>/dev/null)
	
	rm -rf "$destdir"/"$N-doc_$V$R" 2>/dev/null

	if [ x"$docs" != "x" ]; then
		domv $dir/usr/share/doc $destdir/$N-doc_$V$R/usr/share
	fi
	
	if [ x"$gtk_docs" != "x" ]; then
		domv $dir/usr/share/gtk-doc/html $destdir/$N-doc_$V$R/usr/share/gtk-doc
	fi
	
	[ -d $destdir/$N-doc_$V$R ] && echo $destdir/$N-doc_$V$R && return 0
	return 1
}

split_i18n() {
	local dir="$1"
	local localdir="usr/share/locale"
	
	if ls -d $dir/$localdir/* >/dev/null 2>/dev/null; then
		ls -d $dir/$localdir/* |while read line;do
			lang=${line##*/}
			domv $dir/$localdir/$lang      $workdir/$N-i18n-${lang}_$V$R/$localdir
			echo $workdir/$N-i18n-${lang}_$V$R
		done
		return 0
	fi
	
	return 1
}

find_desktop() {
	local source_dir=$1
	local desktop=""
	
	file_is_exist "$source_dir/usr/share/applications/$N-gtk.desktop" && \
		desktop="$source_dir/usr/share/applications/$N-gtk.desktop"
	file_is_exist "$source_dir/usr/share/applications/$N-[[:digit:]].desktop" && \
		desktop="$(ls $source_dir/usr/share/applications/$N-[[:digit:]].desktop)"
	file_is_exist "$source_dir/usr/share/applications/$N.desktop" && \
		desktop="$source_dir/usr/share/applications/$N.desktop"
	file_is_exist "$source_dir/usr/share/applications/kde4/$N.desktop" && \
		desktop="$source_dir/usr/share/applications/kde4/$N.desktop"

	if [ "x$DESKTOPFILE" != "x" ]; then
		file_is_exist "$source_dir/$DESKTOPFILE" && \
			desktop="$source_dir/$DESKTOPFILE"
		file_is_exist "$source_dir/usr/share/applications/$DESKTOPFILE" && \
			desktop="$source_dir/usr/share/applications/$DESKTOPFILE"
	fi

	if [ "x$desktop" != "x" ]; then
		echo "$desktop"
		return 0
	fi

	return 1
}

find_icon() {
	local desktop=$1 
	local source_dir=$2
	local icon_name="$(grep ^Icon= $desktop |sed -e 's/Icon=//g')"

	if file_is_exist "$source_dir/$icon_name"; then
		icon="$source_dir/$icon_name"
	else
		file_is_exist "$source_dir/usr/share/icons/hicolor/scalable/apps/$icon_name.svg" && \
		icon="$source_dir/usr/share/icons/hicolor/scalable/apps/$icon_name.svg"
		icon_name=${icon_name%.svg}
		icon_name=${icon_name%.png}
		icon_name=${icon_name%.xpm}
		icon_name=${icon_name%.jpg}

		for i in 48x48 32x32 24x24 22x22; do
			icon="$source_dir/usr/share/icons/hicolor/"$i"/apps/$icon_name.png"
			file_is_exist "$icon" && break || continue
		done

	fi

	file_is_exist "$source_dir/usr/share/icons/$icon_name.png" && \
		icon="$source_dir/usr/share/icons/$icon_name.png"
	file_is_exist "$source_dir/usr/share/icons/$icon_name.xpm" && \
		icon="$source_dir/usr/share/icons/$icon_name.xpm"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.svg" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name.svg"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.xpm" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name.xpm"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name.png" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name.png"
	file_is_exist "$source_dir/usr/share/pixmaps/$icon_name" && \
		icon="$source_dir/usr/share/pixmaps/$icon_name"

	if [ "x$ICONFILE" != "x" ]; then
		file_is_exist "$source_dir/$ICONFILE" && icon="$source_dir/$ICONFILE"
		file_is_exist "$source_dir/usr/share/pixmaps/$ICONFILE" && \
			icon="$source_dir/usr/share/pixmaps/$ICONFILE"
	fi

	if [ "x$icon" != "x" ] && file_is_exist "$icon"; then
		echo "$icon"
		return 0
	fi

	return 1
}

#
# convert: 
# & -> &amp; 
# < -> &lt;
# > -> &gt;
#
xml_escape_convert() {
	echo "$1" |sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'
}

#
# $1 - source_dir
#
mkpackage() {
	local sha
	local pbsfile
	local atom
	local source_dir="$1"
    local pkginfo_dir="$(dirname $source_dir)/${N}_$V$R-pkginfo"

    mkdir -p $pkginfo_dir
	atom_parse $source_dir
	
	# Creat pkgdate
	cd $source_dir
	find |sort -r |fileinfo >$pkginfo_dir/filelist

	if [ "x$N" = "x$NN-dev" ]; then
		RDEPEND=
		BDEPEND=
		RECOMMENDED=
		PRIORITY=
		INSTALL=
		CONFLICT=
		REPLACE=
		DESCRIPTION="$DESCRIPTION (development files)" 
	else
		install=$INSTALL
		if [ "x$install" != "x" ] && file_is_exist "$filesdir"/$install; then
            docp "$filesdir"/$install var/ypkg/db/"$N"/
            docp "$filesdir"/$install $pkginfo_dir/
        fi
	fi
	
	build_date="$(date +%s)"
	declare -a install_size=($(du $source_dir -sb))
	install_size=${install_size[0]}
	
	# Creat pkginfo
	name=$N
	version=$V$R
	priority=$PRIORITY
	group=$GROUP
	[ x"$REPO" = x ] && REPO="stable"
	repo=$REPO
	rir=$RIR
	alias=$ALIAS
	subdir="$(echo $N |cut -b1 |tr '[A-Z]' '[a-z]')"
	uri="$subdir/$N/"$repo"/${N}_$V$R-$YARCH.$PACK_SUFFIX"
	license="$(xml_escape_convert "$LICENSE")"
	packager="$(xml_escape_convert "$PACKAGER")"
	homepage="$(xml_escape_convert "$HOMEPAGE")"
	install="$INSTALL"
	arch="$YARCH"
	depend=$(xml_escape_convert "$RDEPEND" |xargs |tr " " ",")
	bdepend=$(xml_escape_convert "$BDEPEND" |xargs |tr " " ",")
	redepend=$(xml_escape_convert "$RECOMMENDED" |xargs |tr " " ",")
	conflict=$(xml_escape_convert "$CONFLICT" |xargs |tr " " ",")
	replace=$(xml_escape_convert "$REPLACE" |xargs |tr " " ",")
	description=$(xml_escape_convert "$DESCRIPTION")

	cd $source_dir
	find . |$CPIO --quiet -o -H newc |$XZ -7 >$workdir/$pkgdata
	size=($(du $workdir/$pkgdata -sb))
	size=${size[0]}
	
	local gname
	local gdescription
	
	# desktop and icon
	local desktop=$(find_desktop $source_dir)

	if [ "x$desktop" != "x" ]; then
		cp $desktop  $pkginfo_dir/"$N".desktop
		mkdir -p ${YPK_DEST%/*}/desktops/
		cp $desktop  ${YPK_DEST%/*}/desktops/"$N".desktop
		local icon=$(find_icon $desktop $source_dir)
		
		if [ "x$icon" != "x" ]; then
			local tmp="$N"."${icon##*.}"
			cp $icon  $pkginfo_dir/$tmp
			mkdir -p ${YPK_DEST%/*}/icons/
			cp $icon  ${YPK_DEST%/*}/icons/$tmp
		fi
	
		# Find exec
		grep -q ^Exec= "$desktop" && exec="$(grep ^Exec= "$desktop" |head -n1 |sed 's/^Exec=//g')"
		grep -q ^TryExec= "$desktop" && tryexec="$(grep ^TryExec= "$desktop" |head -n1 |sed 's/^TryExec=//g')"
		
		exec="${exec-$tryexec}"
		exec=$(xml_escape_convert "$exec")
		gname="genericname type=\"desktop\""
		gdescription="description type=\"desktop\""
	else
		gname="genericname"
		gdescription="description"
	fi
	
	category=$(ybs_get_category "$TT" "$desktop")
	
	data_count="1"
	
	cat >$pkginfo_dir/$control <<OOO
<?xml version="1.0" encoding="UTF-8"?>
<PackageInfo>
 <Package name="$name">
   <$gname>
     <keyword lang="en">$name</keyword>
   </genericname>
   <category>$category</category>           
   <arch>$arch</arch>                                        
   <version>$version</version>                            
   <priority>$priority</priority>                    
   <group>$group</group>                    
   <license>$license</license>
   <packager>$packager</packager>
   <homepage>$homepage</homepage>
   <repo>$repo</repo>
   <rir>$rir</rir>
   <alias>$alias</alias>
   <install>$install</install>
OOO

if [ "x$exec" != "x" ]; then
       cat >>$pkginfo_dir/$control <<OOO
   <exec>$exec</exec>
OOO
fi

cat >>$pkginfo_dir/$control <<OOO
   <build_date>$build_date</build_date>    
   <$gdescription>
     <keyword lang="en">$description</keyword>
   </description> 
   <data_count>$data_count</data_count>
   <data id="0">                                                     
     <name>pkgdata</name>                           
     <format>xz</format> 
     <size>$size</size>
     <install_size>$install_size</install_size>        
     <depend>$depend</depend>              
     <bdepend>$bdepend</bdepend>
     <recommended>$redepend</recommended>      
     <conflict>$conflict</conflict>      
     <replace>$replace</replace>      
   </data>                               
 </Package>
</PackageInfo>
OOO
	

	cd $pkginfo_dir
	tar cJf $workdir/$pkginfo *

	# Creat ypk package
	cd $workdir

	if [ "x$2" != "x" ]; then
		target="$2"
		tar cJf $target $pkgdata $pkginfo && echo $target
	else
		YPK_DEST_RAW="$YPK_DEST/$(dirname $uri)"
		mkdir -p $YPK_DEST_RAW/$N
		tar cJf $YPK_DEST/$uri $pkgdata $pkginfo && echo $YPK_DEST/$uri
		cp $pkginfo_dir/filelist $YPK_DEST_RAW/${N}_$V$R-$YARCH.filelist 2>/dev/null
		# update xml, insert size and sha1 value
		local control_target=$YPK_DEST_RAW/${N}_$V$R-$YARCH.xml
		cp $pkginfo_dir/$control $control_target
		local size=$(du "$YPK_DEST/$uri" -sb |awk '{print $1}')
		local sha1=$(sha1sum "$YPK_DEST/$uri" |awk '{print $1}')
		sed -i -e '/\<build_date\>/a\   <size>'"$size"'<\/size>' -e '/\<build_date\>/a\   <sha>'"$sha1"'<\/sha>' $control_target
		# -dev do not copy changelog
		if [ x"${N##*-}" != "xdev" ]; then
			cp $pbsdir/changelog $YPK_DEST_RAW 2>/dev/null
            cp $workdir/${N}_$V$R-$YARCH.buildlog $YPK_DEST_RAW/$N 2>/dev/null
            cp -a $pbsdir/{${N}_$V$R.pbs,files} $YPK_DEST_RAW/$N 2>/dev/null
		fi
        
		#gzip -9 -f $YPK_DEST_RAW/{${N}_$V$R-$YARCH.buildlog,${N}_$V$R-$YARCH.filelist,changelog} 2>/dev/null
	fi
}

#
# Check /dirs permission
#
check_perm_dirs () {
	local dir="$1"
	# These dir(s) in ypk package is invalid
    for i in tmp root proc sys var/run var/lock; do	
		[ -d $dir/${i} ] && rm -rf $dir/${i}
	done
    # These dir(s) permission
	for i in bin boot dev etc home lib media mnt opt sbin usr var; do
		if [ -d $dir/${i} ];then
			chown root:root $dir/${i}
			chmod 755       $dir/${i}
		fi
	done

	rm $dir/{usr/share/mime/mime.cache,usr/share/applications/mimeinfo.cache} 2>/dev/null
	chmod 644 $dir/usr/share/applications/*.desktop 2>/dev/null
}

#
# $1- destdir
#
ybs_mkpackage() {
	[ ! -d $destdir ] && return 0

	# Source packages
	local spacks="$1 "
	NN="$N"

	# check /dirs permission
	check_perm_dirs "$destdir"

	# clean up pipe files
	find "$destdir" -name "*.pipe" -type p -exec rm {} \;

	if [ "x$LANGUAGE" != "x" ];then
		# Strip i18n 
		ybs_strip_i18n $destdir
			
		#strip unnessesary i18n in man path.
		ybs_strip_mani18n $destdir
	fi
	
	# Remove .la files, default is remove.
	local libtool="yes"
	str_isIn "$FEATURES" "libtool" && libtool="yes"
	str_isIn "$FEATURES" "nolibtool" && libtool="no"
	str_isIn "$OPTIONS" "libtool" && libtool="yes" 
	str_isIn "$OPTIONS" "nolibtool" && libtool="no" 
	[ "$libtool" = "yes" ] && ybs_rm_libtool $destdir
	
	# Strip files, default is strip.
	local strip="yes"
	str_isIn "$FEATURES" "strip" && strip="yes"
	str_isIn "$FEATURES" "nostrip" && strip="no"
	str_isIn "$OPTIONS" "strip"  && strip="yes"
	str_isIn "$OPTIONS" "nostrip"  && strip="no"
	[ "$strip" = "yes" ] && ybs_strip_bin $destdir

	# Upx executables files, default is not using upx
	local upx="no"
	str_isIn "$FEATURES" "upx" && upx="yes"
	str_isIn "$FEATURES" "noupx" && upx="no"
	str_isIn "$OPTIONS" "upx" && upx="yes"
	str_isIn "$OPTIONS" "noupx" && upx="no"
	[ "$upx" = "yes" ] && ybs_upx_bin $destdir

	# Split i18n
	#spacks+="$(split_i18n $destdir) "

	# Split dev files, default is split dev file
	local dev="no"
	str_isIn "$FEATURES" "dev" && dev="yes"
	str_isIn "$FEATURES" "nodev" && dev="no"
	str_isIn "$OPTIONS" "dev" && dev="yes"
	str_isIn "$OPTIONS" "nodev" && dev="no"
	[ "$dev" = "yes" ] && spacks+="$(split_dev $destdir) "

	# Split_doc
	#spacks+="$(split_doc $destdir) "

	# Compress man doc info
	ybs_gzip_extra $destdir

	# Mkpackges one by one
	for pack in $spacks; do
		# skip empty dirs
		local files=$(find $pack -type f)
		[ "x$files" = "x" ] && continue
		mkpackage "$pack"
	done
	return 0
}

#
# Cp desktop file to "$destdir"/usr/share/applications
#
dodesktop() {
	local dfile="$1"
	local picture="$2"
	local icon=""
	file_is_exist "$filesdir/${dfile##*/}"   && dfile="$filesdir/${dfile##*/}"
	file_is_exist "$filesdir/${picture##*/}" && picture="$filesdir/${picture##*/}"
	if [ x"$dfile" != x ] && file_is_exist "$dfile"; then
		mkdir -p "$destdir"/usr/share/applications
		install -m755 "$dfile" "$destdir"/usr/share/applications 
	fi
	if [ x"$picture" != x ] && file_is_exist "$picture"; then 
		docp "$picture"   "$destdir"/usr/share/pixmaps
	fi
	dfile="${dfile##*/}"
	picture="${picture##*/}"
	icon=$(grep ^Icon= "$destdir"/usr/share/applications/"$dfile" |sed 's/Icon=//g')
	name=${icon%.*}
	type=${picture##*.}
	if [ x"$type" != x ] && [ x"$picture" != x"$name.$type" ]; then 
		mv "$destdir"/usr/share/pixmaps/"$picture" "$destdir"/usr/share/pixmaps/"$name"."$type" 
	else
		return 0
	fi
}

#
# Add unit for systemd
#
dounit() {
	local file="$@"
	local dir
	#FIXME 
	[ -d /usr/lib/systemd/system ] && dir="$destdir"/usr/lib/systemd/system || dir="$destdir"/lib/systemd/system

	if [ x"$file" != x ]; then
		for i in $@; do
			file_is_exist "$i" && docp "$i" "$dir" || docp "$filesdir/$i" "$dir"
		done
	fi
}

#
# Copy files to /etc/pam.d/
#
dopamd() {
	local file="$@"
	local dir="$destdir"/etc/pam.d/

	if [ x"$file" != x ]; then
		for i in $@; do
			file_is_exist "$i" && docp "$i" "$dir" || docp "$filesdir/$i" "$dir"
		done
	fi
}

docp() {
	local end=${!#}
	mkdir -p "$end"
	cp -a "$@"
}

docp_rename() {
	local end=${!#}
	mkdir -p "$(dirname $end)"
	cp -a "$@"
}

domv() {
	local end=${!#}
	mkdir -p "$end"
	mv "$@"
}

domv_rename() {
	local end=${!#}
	mkdir -p "$(dirname $end)"
	mv "$@"
}

#
# Cp man to dir
#
doman() {
	local name num
	for i in $@; do
		name=${i%.[0-9]}
		num=${i##$name}
		num=${num##.}
		if file_is_exist "$i"; then
			docp ${i} "$destdir"/usr/share/man/man${num}/
		else
			docp "$filesdir/${i}" "$destdir"/usr/share/man/man${num}/
		fi
	done
}

doln(){
	local end=${!#}
	mkdir -p "$(dirname $end)"
	ln -sf $@
}

dofont() {
	for i in $@; do 
		msg "mkfontscale $i"
		mkfontscale "$i"
		msg "mkfontdir $i"
		mkfontdir  "$i"
		msg "fc-cache $i"
		fc-cache -f "$i"
	done
	return 0
}

doinstall_info () {
	msg "install info: $@"
	[ -x /usr/bin/install-info ] || return 0
	infodir=/usr/share/info
	for i in $@; do
		install-info "$infodir"/"$i" $infodir/dir 2>/dev/null
	done	
	return 0
}

doremove_info () {
	msg "remove info: $@"
	[ -x /usr/bin/install-info ] || return 0
	infodir=/usr/share/info
	for i in $@; do
		install-info --delete "$infodir"/"$i" $infodir/dir 2>/dev/null
	done
	return 0
}

dopatch(){
	local file=""
	local dir1=""
	local dir2=""
	local num=""
	while [ "x$1" != "x" ]; do
		file="$1"
		file_is_exist "$file" || file="$filesdir/$1"
		file_is_exist "$file" || file="$filesdir/patches/$1"
		if ! file_is_exist "$file"; then
			rmsg ":( \"$1\" not found."
			exit  1
		fi
		dir1="$(grep ^--- "$file" |head -n1 |awk '{print $2}' |awk -F/ '{print $1}' |tr -d '\r')"
		dir2="$(grep ^+++ "$file" |head -n1 |awk '{print $2}' |awk -F/ '{print $1}' |tr -d '\r')"
		if ls -d "$dir1" >/dev/null 2>/dev/null || ls -d "$dir2" >/dev/null 2>/dev/null;then
			num="0"
		else
			num="1"
		fi
		mmsg "Patching ${file##*/} ..."
		patch -p$num -i "$file" 
		shift
	done
}

# Unpack
dounpack() {
	if [ "x$SRC_URI" = "x" ];then
		for i in tar.bz2 tar.gz bz2 tgz tbz tbz2 rar zip 7z; do
			file_is_exist "$YBS_SOURCE/$N-$V$R.${i}" && SRC_URI="$YBS_SOURCE/$N-$V$R.${i}"
		done
	else
		file_is_exist "$SRC_URI" && SRC_URI="$SRC_URI"
		file_is_exist "$YBS_SOURCE/$SRC_URI" && SRC_URI="$YBS_SOURCE/$SRC_URI"
	fi

	[ "x$SRC_URI" = "x" ] && return 0
	SRC_URI=($SRC_URI)
	local fname=${SRC_URI##*/}
	local tarball="$YBS_SOURCE/$fname"
	local srcdir="$N-$V$R"
	rm -r "$srcdir" 2>/dev/null
	
	case $fname in
		*.tar.*|*.gz|*.tar|*.tgz|*.tbz2|*.tbz|*.bz2)
			mmsg "tar xf $tarball"
			name=($(tar -tf "$tarball" |awk -F/ '{print $1}' |sort -u))

			if [ "x$name" = "x." ] || [ ${#name[@]} -gt 1 ]; then
				mkdir "$srcdir"
				tar xf "$tarball" -C "$srcdir" && return 0
			fi 

			if [ ${#name[@]} -eq 1 ]; then
				tar xf "$tarball" 
				if [ "x$name" != "x$srcdir" ]; then
					mv "$name" "$srcdir" && return 0
				else
					return 0
				fi
			fi
			;;

		*.zip)
			mmsg "unzip xf $tarball"
			name=($(unzip -l "$tarball" |awk '{print $4}' |awk -F/ '{print $1}' |sort -u |sed -e '/^----$/d' -e '/^$/d' -e '/^Name$/d'))

			if [ ${#name[@]} -eq 1 ]; then
				unzip "$tarball"
				if [ "x$name" != "x$srcdir" ]; then
					mv "$name" "$srcdir" && return 0
				else
					return 0
				fi
			else
				unzip "$tarball" -d "$srcdir" && return 0
			fi
			;;

		 *.deb) 
		 	mmsg "ar x $tarball"
                    	name=$(ar t "$tarball" |grep data)
			mkdir -p "$srcdir" && cd "$srcdir"
			ar x "$tarball"
			mkdir -p data 
			tar xf "$name" -C data && cd ../ && return 0	 
			;;

		 *.rpm) 
		 	mmsg "unpack $tarball" 
			name=${fname%.rpm}
			mkdir -p "$srcdir" && cd "$srcdir"
		 	rpm2tarbz2 "$tarball"
			mkdir -p data
			tar xf $name.tar.bz2 -C data && cd ../ && return 0
			;;

		*.7z)   
			mmsg "7z x $tarball"
			name=$(7z l "$tarball" |grep -A2 "Size   Compressed  Name" |tail -n1 |awk '{print $6}')	
			name=${name%%/*}
			7z x "$tarball" 
			if [ "x$name" != "x$srcdir" ]; then
				mv "$name" "$srcdir" && return 0
			else
				return 0
			fi
			;;
	       
	       *.git)
		        name="$N"
		    	mmsg "cp -a ${YBS_SOURCE}/"$name" $PWD/"$srcdir""
		        cp -a ${YBS_SOURCE}/"$name" "$srcdir" && return 0 
			;;
	       
	       *.rar) 
			mmsg "unrar xf $tarball"
			unrar x "$tarball" && return 0
			;;
	  
	       *)   
	       		if [ -d "$tarball" ]; then
				mmsg "cp -a "$tarball" $PWD/"$srcdir""
				cp -a "$tarball" "$srcdir" && return 0
			fi
	esac
	return 1
}

# Configure
doconfig() {
	local command=""
	local command1=""
	local command2=""

	# waf
	[ -x waf ] && command="./waf configure $(echo $config |xargs) $@"
	if [ x"$command" != x ];then
		mmsg "$command"
		eval $command && return 0 || command=""
	fi
	
	# generic
	[ -x configure ] && command="./configure $(echo $config |xargs) $@"
	[ -x Configure ] && command="./Configure $(echo $config |xargs) $@"
	if [ x"$command" != x ];then
		mmsg "$command"
		eval $command && return 0 || command=""
	fi

	# autogen
	if [ -x autogen.sh ];then
		command="./autogen.sh" 
		command1=" ./configure $(echo $config |xargs) $@"
	fi
	if [ x"$command" != x ];then
		mmsg "$command; $command1"
		eval $command
		eval $command1 && return 0 || command=""
	fi
	
	# perl module
	file_is_exist Makefile.pl && mv Makefile.pl Makefile.PL
	file_is_exist Makefile.PL && command="perl Makefile.PL -y PREFIX=/usr $@"
	if [ x"$command" != x ];then
		mmsg "$command"
		if ! eval $command; then
			command="perl Makefile.PL PREFIX=/usr $@"
			mmsg "$command"  
			eval $command && return 0 || command=""
		else
			return 0
		fi
	fi

	# cmake
	if file_is_exist CMakeLists.txt; then
		command="mkdir -p build"
		command1="cd build"
		command2="cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_INSTALL_LIBDIR=/usr/lib"$LIBDIRSUFFIX" -DLIB_INSTALL_DIR=/usr/lib"$LIBDIRSUFFIX" -DLIB_SUFFIX="$LIBDIRSUFFIX" $@ .." 
		mmsg "$command; $command1; $command2"
		eval $command
		eval $command1
		eval $command2 && return 0 || command=""
	fi

	# qmake
	if ls *.pro >/dev/null 2>/dev/null; then
		command="qmake $@"
        if [ x"$command" != x ];then
		    mmsg "$command"
		    eval $command && return 0 || command=""
        fi
	fi

	# scons
	if file_is_exist SConstruct; then
		command="scons $(echo $config |xargs) $@"
        if [ x"$command" != x ];then
		    mmsg "$command"
		    eval $command 
        fi
	fi	
}

# Make
domake() {
	local command="make $MAKEOPTS $@"
	# waf
    if [ -x waf ];then
		command="./waf build $MAKEOPTS $@"
        if [ x"$command" != x ];then
		    mmsg "$command"
		    eval $command && return 0 || command=""
        fi
	fi
	# setup.py
    if file_is_exist setup.py; then
		if [ "x$1"  = "xmake" ]; then
			command="make $MAKEOPTS $@"
		else
			command="python setup.py build $@"
		fi
        if [ x"$command" != x ];then
	    	mmsg "$command"
		    eval $command && return 0 || command=""
        fi
	fi
    # generic
	if file_is_exist Makefile || file_is_exist GNUmakefile; then
		command="make $MAKEOPTS $@" 
	fi
    # misc
	file_is_exist makefile.linux && command="make $MAKEOPTS -f makefile.linux $@"
	file_is_exist Imakefile && command="make $MAKEOPTS $@"
	file_is_exist SConstruct && return 0
    if [ x"$command" != x ];then
    	mmsg "$command"
    	eval $command
    fi
}

# Make install
domkinstall() {
	local command="make DESTDIR="$destdir" "$@" install"
	# waf
    if [ -x waf ];then
		command="./waf install --destdir="$destdir" $@"
        if [ x"$command" != x ];then
		    mmsg "$command"
		    eval $command && return 0 || command=""
        fi
	fi
    # setup.py
	if file_is_exist setup.py;then
		if [ "x$1"  = "xmake" ]; then
			command="make DESTDIR="$destdir" $@ install"		
		else
			command="python setup.py install --prefix=/usr --root="$destdir" $@"
		fi
        if [ x"$command" != x ];then
		    mmsg "$command"
		    eval $command && return 0 || command=""
        fi
	fi
	# scons	
	if file_is_exist SConstruct;then
		if [ x"$@" = x ]; then
			command="scons --install-sandbox="$destdir" "$@" install"
		else
			command="scons "$@" install"
		fi
        if [ x"$command" != x ];then
		    mmsg "$command"
		    eval $command && return 0 || command=""
        fi
	fi	
    # generic
	if file_is_exist Makefile || file_is_exist GNUmakefile; then
		command="make DESTDIR="$destdir" "$@" install"
	fi
    if [ x"$command" != x ];then
	    mmsg "$command"
	    eval $command 
    fi
}

# Cp src file to specified dir
dosrc() {
	mmsg "Copy source files: /usr/src/"${N}_$V$R""
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	cp -a "$@" "$destdir"/usr/src/"${N}_$V$R"/
}

# Cp supported to specified dir
dosupported() {
	mmsg "Copy supported file: $1"
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	install -m755 "$filesdir/$1" "$destdir"/usr/src/"${N}_$V$R"/"${N}"_supported
}

# Cp ykms.conf to specified dir
doykms() {
	mmsg "Copy ykms file: ykms.conf"
	mkdir -p "$destdir"/usr/src/"${N}_$V$R"
	install -m755 "$filesdir/ykms.conf" "$destdir"/usr/src/"${N}_$V$R"
}

# Cp doc to specified dir
dodoc() {
	mmsg "Copy documents: $@"
	install -m755 -d "$destdir"/usr/share/doc/"$N"/
	cp -a "$@" "$destdir"/usr/share/doc/"$N"/
}

# Ypkg useradd
douseradd() {
	local end=${!#}
	if ! getent passwd "$end" >/dev/null; then 
		msg "Creating: user $end"
		useradd "$@"
	fi
}

# Ypkg userdel
douserdel() {
	local end=${!#}
	if getent passwd "$end" >/dev/null; then 
		msg "Deleting: user $end"
		userdel "$@"
	fi
}

# Ypkg groupadd
dogroupadd() {
	local end=${!#}
	if ! getent group "$end" >/dev/null; then
		msg "Creating: group $end"
		groupadd "$@"
	fi
}

# Ypkg groupdel
dogroupdel() {
	local end=${!#}
	if getent group "$end" >/dev/null; then
		msg "Deleting: group $end"
		groupdel "$@"
	fi
}

dolibtool_finish () {
	local dir="$@"
	msg "Libtool finish: $dir"
	libtool --finish --silent $dir
}

perl_cleanup () {
	msg "Delete: .packlist *.pod files"
	find "$destdir" -name '.packlist' -delete
	find "$destdir" -name '*.pod' -delete
}

glib_compile_schemas() {
	if [ -x /usr/bin/glib-compile-schemas ]; then
		msg "glib-compile-schemas /usr/share/glib-2.0/schemas"
		/usr/bin/glib-compile-schemas  /usr/share/glib-2.0/schemas/
	else
		msg ":( /usr/bin/glib-compile-schemas not found."
		return 1
	fi
	return 0
}

doinstall_catalog() {
	local bin=$(which install-catalog)
	if [ -x $bin ]; then
		$bin --add $@
	fi
}

doremove_catalog() {
	local bin=$(which install-catalog)
	if [ -x $bin ]; then
		$bin --remove $@
	fi
	
}

# Install defaut settings
gnome2_install_defaut_gconf() {
	#type
	local t=$1	
	#name
	local n=$2
	#value
	local v=$3
	msg "Setting: \"$n\" \"$v\""
	if [ -x /usr/bin/gconftool-2 ]; then
		configfile=$(/usr/bin/gconftool-2 --get-default-source)
		if [ "x$t" = "xlist" ];then
			/usr/bin/gconftool-2 --direct --config-source="$configfile" --type list --set "$n" --list-type string "$v"
		else
			/usr/bin/gconftool-2 --direct --config-source="$configfile" --type "$t" --set "$n" "$v"
		fi
	fi
}

# Install schemas
mate_install_schema() {
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/mateconftool-2 ];then
		for schema in $schemas; do
			msg "Installing: $schema"
			MATECONF_CONFIG_SOURCE="$(mateconftool-2 --get-default-source)" mateconftool-2 --makefile-install-rule "$schema"  >/dev/null
		done
	fi
}

# Unstall schemas
mate_uninstall_schema() {
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/mateconftool-2 ];then
		for schema in $schemas; do
			msg "Uninstalling: $schema"
			MATECONF_CONFIG_SOURCE="$(mateconftool-2 --get-default-source)" mateconftool-2 --makefile-uninstall-rule "$schema"  >/dev/null
		done
	fi
}

# Install schemas
gnome2_install_schema() {
	#this is this-is-deprecated
	#return 0
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/gconftool-2 ];then
		for schema in $schemas; do
			msg "Installing: $schema"
			GCONF_CONFIG_SOURCE="$(gconftool-2 --get-default-source)" gconftool-2 --makefile-install-rule "$schema"  >/dev/null
		done
	fi
}

# Unstall schemas
gnome2_uninstall_schema() {
	#this is this-is-deprecated
	#return 0
	local schemas="$@"
	if [ x"$schemas" != x ] && [ -x /usr/bin/gconftool-2 ];then
		for schema in $schemas; do
			msg "Uninstalling: $schema"
			GCONF_CONFIG_SOURCE="$(gconftool-2 --get-default-source)" gconftool-2 --makefile-uninstall-rule "$schema"  >/dev/null
		done
	fi
}

# Install mine
gnome2_install_mine() {
	local mines="$@"
	if [ x"$mines" != x ] && [ -x /usr/bin/xdg-mime ];then
		for mine in $mines; do
			msg "Installing: $mine"
			xdg-mime install --mode system "$mine"  >/dev/null
		done
	fi
}

# Unstall mine
gnome2_uninstall_mine() {
	local mines="$@"
	if [ x"$mines" != x ] && [ -x /usr/bin/xdg-mime ];then
		for mine in $mines; do
			msg "Uninstalling: $mine"
			xdg-mime uninstall --mode system "$mine"  >/dev/null
		done
	fi
}

# Update rarian database
gnome2_rarian_sk_update() {
	if [ -x /usr/bin/rarian-sk-update ]; then
		msg "Updating rarian database ..."
		/usr/bin/rarian-sk-update
	fi
}

# Update desktop entries
gnome2_desktop_database_update() {
	if [ -x /usr/bin/update-desktop-database ]; then
		msg "Updating desktop database ..."
		/usr/bin/update-desktop-database
	fi
}

# Restart gconfd-2 if running to reload new gconf settings
gnome2_gconfd_reload() {
	if ps acx | grep -q gconfd-2; then
		msg "Reloading gconfd settings ..."
		killall -HUP gconfd-2
	fi
}

# Update gtk-immodules
gnome2_gtk_immodules_update() {
	if [ -x /usr/bin/update-gtk-immodules ]; then
		msg "Updating gtk immodules ..."
		update-gtk-immodules --verbose
        fi
}

# Update gdk pixbuf loaders
gnome2_gdk_pixbuf_loaders_update() {
	if [ -d /etc/gtk-2.0 ] && [ -x /usr/bin/update-gdk-pixbuf-loaders ]; then
		msg " Updating gdk pixbuf loaders ..."
		update-gdk-pixbuf-loaders
	fi
}

#
# Updates Gtk+ icon cache files under /usr/share/icons if the current pbs
# have installed anything under that location.
#
gnome2_icon_cache_update() {
	local dir=""
	#gnome2_icon_cache_update /usr/share/icons/titans|titans
	local updater="$(type -p gtk-update-icon-cache 2> /dev/null)"
	if [ "x$*" = "x" ]; then
		dir="/usr/share/icons/hicolor"
	else
		while [ "x$1" != "x" ]; do
			if [ ! -d "$1" ]; then
				dir+="/usr/share/icons/"${1##*/}" "
			else	
				dir+="$1 "
			fi
			shift
		done
	fi
	msg "Updating icons cache: $dir"
	"$updater" -f -q -t $dir
}

# Update mime database
gnome2_mime_database_update() {
	if [ -x /usr/bin/update-mime-database ]; then
		/usr/bin/update-mime-database /usr/share/mime/ 
	fi
}

# Reboot flag
flag_reboot() {
	local flag="/run/ypkg/reboot"
	mkdir -p /run/ypkg
	touch "$flag"
}

#
# Install package
#

#
#fetch           break after download source tarball
#upack           break after unpack source tarball
#patch           break after patch source
#config          break after configure	
#make           break after make a.k.s compile
#check		 break after make check/test
#mkinstall         break after make install    
#package         break after make ypk package    
#
maybe_break() {
	local string="$1"
	local command="$(echo $@ |sed 's/'"$string"'//')"
	if echo "$BREAK" | egrep -q "(,|^)$string(,|$)"; then
		$command
		exit 1
	fi
}

#
# $1 - as follows:
# pkgname - lftp
# pkgtype/pkgname -net-ftp/lftp
# pbsfile - lftp_4.3.3.pbs 
#
ybs_build() {
	local string="$1"
	local stat

	if ! ybs_getpbsfile "$string"; then
		rmsg ":( $string not found."
		return 1
	fi

	ybs_searchInstalled $T $N $V$R >/dev/null
	
	local new=$V$R
	local force_flag=""	
	[ "x$FORCE_INSTALL" = "xyes" ] && force_flag="F"
	
	# N -- new install
	# U -- upgrade
	# D -- downgrade
	# E -- same version
	if [ "x$INSTALL_STATUS" = "xuninstall" ]; then
		stat="N"
		ymsg_ "[$stat$force_flag]"
                msg " $T/${N}_$V$R "
	else
		atom_cmp $INSTALL_VERSION $new 
		case $? in
			1) stat="D"  
			   mmsg_ "[$stat$force_flag]" 
			   msg " $T/${N}_$INSTALL_VERSION ----> $T/${N}_$V$R "	
			   ;;
	 		2) stat="U"  
			   rmsg_ "[$stat$force_flag]" 
			   msg " $T/${N}_$INSTALL_VERSION ----> $T/${N}_$V$R "	
			   ;;
	 		0) stat="E"  
                           gmsg_ "[$stat$force_flag]"
                           msg " $T/${N}_$V$R "
                           [ "x$FORCE_INSTALL" != "xyes" ] && return 0 
                           ;; 
		esac
	fi

	[ "x$PRETEND" = "xyes" ] && return 0
	
	ybs_begin_download $NEWEST || return 1

	maybe_break fetch 

	#
	# Download ok, install it.
	#		
	
	workdir="$WORKING_FIELD/$N"
	rm -rf "$workdir"  2>/dev/null
	mkdir -p $workdir
	srcdir="$workdir"/"$N-$V$R"	
	
	cd $workdir
	
	ymsg ">> $T/${N}_$V$R unpack"
	pbs_unpack
	err_check ":( $T/${N}_$V$R call pbs_unpack failed"

	maybe_break unpack pwd

	destdir="$workdir/${N}_$V$R"
	local pbsfile="$NEWEST"
	local pbsdir="${NEWEST%/*.pbs}"
	filesdir="${pbsdir}"/files
	buildlog="$PWD/${N}_$V$R-$YARCH.buildlog"

	local 	 patchpipe="$PWD/patch.pipe"
	local     patchlog="$PWD/patch-log"
	local 	 configpipe="$PWD/config.pipe"
	local     configlog="$PWD/configure-log"
	local      makepipe="$PWD/make.pipe"
	local       makelog="$PWD/make-log"
	local     checkpipe="$PWD/check.pipe"
	local      checklog="$PWD/check-log"
	local mkinstallpipe="$PWD/mkinstall.pipe"
	local  mkinstalllog="$PWD/mkinstall-log"

	mkdir -p "$srcdir"
	cd "$srcdir"

	ymsg ">> $T/${N}_$V$R patch"
	[ -p $patchpipe ] || mkfifo $patchpipe
	tee $patchlog < $patchpipe & 
	pbs_patch > $patchpipe
	err_check ":( $T/${N}_$V$R call pbs_patch failed"

	maybe_break patch pwd

	ymsg ">> $T/${N}_$V$R configure"
	
	# use distcc if it is requested
	local distcc="no"
	str_isIn "$FEATURES" "distcc" && distcc="yes"
	str_isIn "$FEATURES" "nodistcc" && distcc="no"
	str_isIn "$OPTIONS" "distcc" && distcc="yes"
	str_isIn "$OPTIONS" "nodistcc" && distcc="no"

	if [ "$distcc" = "yes" ]; then
		[[ -d /usr/lib/distcc/bin ]] && export PATH="/usr/lib/distcc/bin:$PATH"
		export DISTCC_HOSTS
		gmsg "distcc is enabled, hosts: $DISTCC_HOSTS"
	fi

	# use ccache if it is requested
	local ccache="no"
	str_isIn "$FEATURES" "ccache" && ccache="yes"
	str_isIn "$FEATURES" "noccache" && ccache="no"
	str_isIn "$OPTIONS" "ccache" && ccache="yes"
	str_isIn "$OPTIONS" "noccache" && ccache="no"

	if [ "$ccache" = "yes" ]; then
		[[ -d /usr/lib/ccache/bin ]] && export PATH="/usr/lib/ccache/bin:$PATH"
		export CCACHE_DIR
		ccache -M $CCACHE_SIZE >/dev/null 
		gmsg "ccache is enabled, ccache_dir: $CCACHE_DIR, ccache_size: $CCACHE_SIZE"
	fi

	[ -p $configpipe ] || mkfifo $configpipe
	tee $configlog < $configpipe & 
	pbs_config > $configpipe
	err_check ":( $T/${N}_$V$R call pbs_config failed"

	maybe_break config pwd

	ymsg ">> $T/${N}_$V$R compile"
	[ -p $makepipe ] || mkfifo $makepipe
	tee $makelog < $makepipe & 
	pbs_build > $makepipe
	err_check ":( $T/${N}_$V$R call pbs_build failed"

	maybe_break make pwd

	ymsg ">> $T/${N}_$V$R make check"
	[ -p $checkpipe ] || mkfifo $checkpipe
	tee $checklog < $checkpipe & 
	pbs_check > $checkpipe
	err_check ":( $T/${N}_$V$R call pbs_check failed"

	maybe_break check pwd

	ymsg ">> $T/${N}_$V$R make install"
	local packs=""
	local destdirs=($destdir)
	local descfiles=($descfiles)
	TT="$T"
	
	gene_desc() {
		local file=$1
        	cat >$file <<EOF
N="$N"
V="$V"
R="$R"
DESCRIPTION="$DESCRIPTION"
COMMENTS="$COMMENTS"
HOMEPAGE="$HOMEPAGE"
REPO="$REPO"
RIR="$RIR"
ALIAS="$ALIAS"
YARCH="$YARCH"
LICENSE="$LICENSE"
PRIORITY="$PRIORITY"
GROUP="$GROUP"
PACKAGER="$PACKAGER"
RDEPEND="$RDEPEND"
BDEPEND="$BDEPEND"
RECOMMENDED="$RECOMMENDED"
CONFLICT="$CONFLICT"
REPLACE="$REPLACE"
OPIONAL="$OPIONAL"
INSTALL="$INSTALL"
OPTIONS="$OPTIONS"
EOF
}
	gene_desc /tmp/"$N"-base.desc 
	descfiles[0]="/tmp/"$N"-base.desc"
	
	[ -p $mkinstallpipe ] || mkfifo $mkinstallpipe
	tee $mkinstalllog < $mkinstallpipe & 
	pbs_install > $mkinstallpipe
	err_check ":( $T/${N}_$V$R call pbs_install failed"

	if [ "x$PROVIDE" != "x" ]; then	
		ymsg ">> $T/${N}_$V$R split $PROVIDE."
		j=1

		for i in $PROVIDE; do
			. ${descfiles[0]}
			destdir="$workdir/${i}_$V$R"
			rm -rf "$destdir" 2>/dev/null
			atom_parse $destdir
		
			ymsg ">> $TT/${N}_$V$R make install"
			# cd "$srcdir"
			config=$DEFAULT_CONFIG
			${i}_install
			err_check ":( $TT/${N}_$V$R call ${N}_install failed"

			gene_desc /tmp/$N.desc
			descfiles[$j]="/tmp/$N.desc"
			destdirs[$j]=$destdir
			blank_funcs
			let j=$j+1
		done

	fi

	>$buildlog
	[ -e $configlog ] && cat $configlog >> $buildlog
	[ -e $makelog ]   && cat $makelog >> $buildlog
	[ -e $checklog ]  && cat $checklog >> $buildlog
	[ -e $mkinstalllog ] && cat $mkinstalllog >> $buildlog

	maybe_break mkinstall pwd

	# make pkg package
	j=0
	for destdir in ${destdirs[@]}; do
		atom_parse $destdir
		ymsg ">> $TT/${N}_$V$R make package"
		. ${descfiles[$j]}
		packs+="$(ybs_mkpackage $destdir) "
		err_check ":( $TT/${N}_$V$R make binary package failed"
		blank_funcs
		let j=$j+1
	done

	rm ${descfiles[@]} 2>/dev/null

	packs=$(echo $packs |tr ' ' '\n' |sort -u |xargs)

	maybe_break package "echo $packs"

	# install to system
	ymsg ">> $TT/${N}_$V$R $PROVIDE install to system"

	for pack in $packs; do
		case "x$AUTO_INSTALL" in
			xyes) mmsg "Install: $pack"
			      ypkg "$YPKG_OPT" -I $pack ;;
			   *) gmsg "$pack"
		esac
	done

	[ -d $workdir ] && rm -r $workdir

	return 0
}

#
# $1 pkgname
# $2 notes/comments/depend/pbs
#
ybs_show() {
	local ret
	local itype
	local iname
	local iver
	local irver
	ybs_getpbsfile "$1"

	if [ $? == 0 ]; then
		atom_parse $NEWEST
		itype=$T
		iname="$N"
		iver=$V
		irver=$R
		. "$NEWEST"
		
		case $2 in
		notes)
			echo -e "$NOTES" ;;
		comments)
			echo -e "$COMMENTS" ;;
		depend)
			local pbsfile=${NEWEST##*/}
			msg_ "Dependencies of "
			wmsg "${pbsfile%*.pbs}:"
			gmsg "Build_time"
			echo $BDEPEND |xargs
			gmsg "Run_time"
			echo $RDEPEND |xargs
			gmsg "Recommend"
			echo $RECOMMENDED |xargs
			gmsg "Conflict"
			echo $CONFLICT |xargs 
			gmsg "Replace"
			echo $REPLACE |xargs ;;
		pbs)
			echo "$NEWEST"
		esac
	else
		rmsg ":( $1 not found."
		return 1
	fi
}

ybs_whatrequires() {
	local string="$1"
	local depend 
	local file
	ymsg ""$string" is related with:"
	
	find "$PBSLIB_PATH" -maxdepth 3 -type f -name "*.pbs" |while read file; do
		. "$file"
		for depend in RDEPEND BDEPEND RECOMMENDED CONFLICT REPLACE; do
			if str_isIn "$(eval "echo \$${depend}")" "$string"; then
				case $depend in
				RDEPEND)
					gmsg_ "[R] "
					msg "$file"  ;;
				BDEPEND)
					ymsg_ "[B] "
					msg "$file"  ;;
			    RECOMMENDED) 
					bmsg_ "[A] "
					msg "$file"  ;;
			       CONFLICT)
					rmsg_ "[C] "
					rmsg "$file" ;;
			       REPLACE)
					rmsg_ "[S] "
					rmsg "$file"
				esac
			fi
		done
		blank_funcs pbs
	done

	msg ""
}

# End of file
