#!/bin/bash
#
# yget -- ypkg package management tool
# 
# Maintainer:  Ylmf OS Developers <ylmfos@115.com>
#

#
#
# reload parameters if available
[ -f /etc/yget.conf ] && . /etc/yget.conf
[ -f /usr/lib/ybs/funcs ] && . /usr/lib/ybs/funcs

# creat paths
mkdir -p $YPPATH_FIELD $YPPATH_DEST $YPPATH_PKGDEST
TMPDIR="/tmp/yget_work"
#trap "rm -r $TMPDIR 2>/dev/null" INT

#
yget_version="0.1"

#
#
usage() {
        cat <<EOF
$0 $yget_version 

Usage: $0 command [options] pkg1 [pkg2 ...]

yget is a simple command line interface for downloading and
installing packages. The most frequently used commands are update
and install.

Commands:
	install               install packages and dependencies (pkg is leafpad not leafpad_0.8.17.ypk)
	install-dev           install build-dependencies for packages (pkg is leafpad not leafpad_0.8.17.ypk)
	remove                remove single package
	search                search packages
	clean                 remove all downloaded packages
	upgrade               upgrade system
	update                retrieve new lists of packages

Options:
	-p                    instead of actually install, simply display what to do
	-y		      assume Yes to all queries
	-d		      download only - do NOT install
	-f                    force install 
EOF
	return 1
}

#
#
yget_mktemp(){
	if [ ! -d $TMPDIR ]; then
		mkdir -p $TMPDIR
		chmod 777 $TMPDIR
	fi
	type=$1
	case $type in
	f|file) mktemp -p $TMPDIR ;;
	d|dir)  mktemp -dp $TMPDIR
	esac
}

#
# get_value depend file
get_value () {
	local element=$1
	local file=$2
	local value=
	case $element in
		size) value="$(grep "<$element>" $file |head -n1)" ;;
		   *) value="$(grep "<$element>" $file |sort -u)" 
	esac
	value=${value//<$element>/}
	value=${value//<\/$element>/}
	value=${value//,/ }
	echo $value

}

#
do_update() {
	local universe="universe.tar.bz2"
	local appinfo_dir="/usr/share/app-info"
	local sha="universe.tar.bz2.sha1sum"
	local download="yes"
	local shatool="${sha##*.}"
	msg_ "* Fetching universe:  $YPPATH_URI/$universe"
	server_sha="$(wget -q -O - $YPPATH_URI/$sha)"
	if [ "x$server_sha" = "x" ]; then
		echo "Can not connect to sever, please mail to <ylmfos@115.com>" 1>&2
		return 1
	fi
	if [ -f ${YPPATH_UNI%/*}/$universe ]; then
		declare -a local_sha=($($shatool ${YPPATH_UNI%/*}/$universe))
		local_sha=${local_sha[0]}
		[ "x$local_sha" = "x$server_sha" ] && download="no"
	fi
	if [ "x$download" = "xyes" ] || [ ! -f $YPPATH_UNI ]; then
		wget -q $YPPATH_URI/$universe -O ${YPPATH_UNI%/*}/$universe
		if [ "$?" == "0" ]; then
			cd ${YPPATH_UNI%/*}
			cp $YPPATH_UNI $YPPATH_UNI- 2>/dev/null
			if ! tar xf $universe; then
				rm ${YPPATH_UNI%/*}/$universe
				echo "$universe was damaged, please mail to <ylmfos@115.com>" 1>&2
			fi
		fi
	fi
	echo
	msg_ "* Updating app-info pool:  "
	if [ -d $appinfo_dir/.git ]; then
		cd $appinfo_dir
		git pull >/dev/null && msg "already up-to-date." 
	else
		cd $(dirname $appinfo_dir)
		[ -d /etc ] || mkdir /etc
		[ -f /etc/hosts ] || touch /etc/hosts
		git config --system --add user.name  ylmfos_user
		git config --system --add user.email ylmfos_user@115.com
		git clone git://git.ylmf.com/app-info.git
	fi
	return 0
}

#
convert() {
	local value=$1
	if [ $value -eq 0 ]; then
		echo 0K
		return 0
	fi
	if [ $(($value/1073741824)) -gt 0 ]; then
		result=$(echo "scale=2; $value/1073741824" |bc)G
		echo $result
		return 0
	fi
	if [ $(($value/1048576)) -gt 0 ]; then 
		result=$(echo "scale=2; $value/1048576" |bc)M
		echo $result
		return 0
	fi
	if [ $(($value/1024)) -gt 0 ]; then
		result=$(echo "scale=2; $value/1024" |bc)K
		echo $result
		return 0
	fi
	return 1
}


#
get_allver() {
	local ver=
	local allver=
	local file=$1
	vers="$(get_value version $file)"
	for ver in $vers; do
		atom_parse ${N}_$ver
		ypkg_find_info $YPPATH_UNI >$tmpfile
		repo="$(get_value repo $file)"
		build_date="$(get_value build_date $file)"
		build_date=$(date -d "1970-01-01 UTC $build_date seconds" +%F,%T 2>/dev/null)
		case $repo in
		       *testing*)	repo="t" ;;
		               *)	repo="s" 
		esac
		allver+="$(mmsg $V$R[$repo] $build_date) |"
	done
	echo $allver
}

#
do_search () {	
	tmpfile=$(yget_mktemp f)
	atom_parse_type "$1"
	local app="$N"
	apps=$(grep "<Package name=" $YPPATH_UNI |sed -e 's/<Package name="//g' -e 's/">//g' |grep $app |sort -u |tr '\n' ' ')
	if [ "x$apps" = "x" ]; then
		rmsg "* $1 not found"
		rm -rf $tmpfile 2>/dev/null
		return 1
	fi
	for app in $apps; do
		atom_parse_type $app
		ypkg_find_info $YPPATH_UNI >$tmpfile
		if [ "x$?" = "x1" ]; then
			rmsg "* $app not found"
			return 1
		else
			if is_installed $N; then
				gmsg_ "[I] "
				wmsg $N
				desc=$(ls $YPPATH_DB/$N/$N_*.desc 2>/dev/null)
				if [ -f $desc ]; then
					atom_parse_path $desc
					[ -f $desc ] && . $desc
					if [ "x$INSTALL_TIME" != "x" ]; then
						INSTALL_TIME=$(date -d "1970-01-01 UTC $INSTALL_TIME seconds" +%F,%T 2>/dev/null)
					fi
				fi
			else
				msg_ "[*] "
				wmsg $N
				HOMEPAGE="$(get_value homepage $tmpfile)"
				DESCRIPTION="$(sed -n '/<description.*>/,/<\/description>/p' $tmpfile |grep "<keyword lang=\"en\"" \
					       |sed -e 's/<keyword lang="en">//g' -e 's/<\/keyword>//g')"
			fi
			echo -e "\t$(gmsg "Installed:") $(ymsg $V$R) $INSTALL_TIME"
			allver="$(get_allver $tmpfile)"
			echo -e "\t$(gmsg "Available:") $allver"
			echo -e "\t$(gmsg "Homepage:") $HOMEPAGE"
			echo -e "\t$(gmsg "Description:") $DESCRIPTION"
			echo
		fi
	done
	rm -rf $tmpfile 2>/dev/null
}

#
get_final_ver () {
	local N=$1
	local file=$2
	local tmpfile=$(yget_mktemp f)
	versions="$(get_value version $file)"
	max_ver="0"
	for version in $versions; do
		atom_parse_type ${N}_$version
		ypkg_find_info $allinfo >$tmpfile
		repo="$(get_value repo $tmpfile)"
		if [ "x$ACCEPT_REPO" = "xstable" ]; then
			[ "x$repo" != "xstable" ] && continue
		fi
		atom_vercmp $max_ver $version
		case $? in
		2)  max_ver=$version
		esac  
	done
	echo $max_ver
}


#
install_prepare () {
	allinfo=$(yget_mktemp f)
	singleinfo=$(yget_mktemp f)
	local app="$1"
	atom_parse_type $app
	ypkg_find_info $YPPATH_UNI >$allinfo
	if [ "x$(cat $allinfo)" = "x" ]; then
		echo "app: $app not found" 1>&2
		rm -rf $allinfo $singleinfo 
		exit 1
	else	
		if [ "x$V$R" = "x" ]; then
			pack_final_ver=$(get_final_ver $N $allinfo)
			if [ "x$pack_final_ver" = "x0" ];then
				echo "app: $app not found" 1>&2
			        rm -rf $allinfo $singleinfo
				exit 1
			fi
		else
			pack_final_ver="$V$R"
		fi
		set +x
		packname=$N
		atom_parse ${packname}_$pack_final_ver
		ypkg_find_info $allinfo  >$singleinfo
		     depends="$(get_value   depend     $singleinfo)"
		   redepends="$(get_value recommended  $singleinfo)"
		   codepends="$(get_value   conflict   $singleinfo)"
		        size="$(get_value   size       $singleinfo)"
		install_size="$(get_value install_size $singleinfo)"
		         uri="$(get_value   uri        $singleinfo)"
		         sha="$(get_value   sha        $singleinfo)"
		for depend in $depends; do
			atom_parse_type $depend
			depend_name=$N
			is_installed $N $V$R && continue 
			ypkg_find_info $YPPATH_UNI >$allinfo
			if [ "x$(cat $allinfo)" = "x" ]; then
				echo "dep: $depend not found" 1>&2
				rm -rf $allinfo $singleinfo 
				exit 1
			else
				if [ "x$V$R" = "x" ]; then
					depend_final_ver=$(get_final_ver $depend $allinfo)
				else	
					depend_final_ver="$V$R"
				fi
				         depuri="$(get_value   uri        $allinfo)"
				         depsha="$(get_value   sha        $allinfo)"
				        depsize="$(get_value   size       $allinfo)"
				depinstall_size="$(get_value install_size $allinfo)"
				echo $depend_name $depend_final_ver $depuri $depsha $depsize $depinstall_size
			fi
		done
		echo $packname $pack_final_ver $uri $sha $size $install_size
		#
		. /etc/environment
		lang=zh_CN
		case $LANG in 
			zh_CN.UTF-8) lang=zh_CN ;;
				*)    lang=$LANG
		esac
		if [ "x$LANG" != "x" ]; then
			atom_parse_type $packname-i18n-${lang}_$pack_final_ver
			if ! is_installed $N $V$R; then
				ypkg_find_info $YPPATH_UNI  >$singleinfo
				if [ "x$(cat $singleinfo)" != "x" ]; then
					         languri="$(get_value   uri        $singleinfo)"
					         langsha="$(get_value   sha        $singleinfo)"
					        langsize="$(get_value   size       $singleinfo)"
					langinstall_size="$(get_value install_size $singleinfo)"
					echo $packname-i18n-$lang $pack_final_ver $languri $langsha $langsize $langinstall_size
				fi
			fi	
		fi
		for redepend in $redepends; do
			atom_parse_type $redepend
			redepend_name=$N
			is_installed $N $V$R && continue 
			ypkg_find_info $YPPATH_UNI >$allinfo
			if [ "x$(cat $allinfo)" = "x" ]; then
				echo "redep: $redepend not found"
			else
				if [ "x$V$R" = "x" ]; then
					redepend_final_ver=$(get_final_ver $redepend $allinfo)
				else	
					redepend_final_ver="$V$R"
				fi
				         redepuri="$(get_value   uri        $allinfo)"
				         redepsha="$(get_value   sha        $allinfo)"
				        redepsize="$(get_value   size       $allinfo)"
				redepinstall_size="$(get_value install_size $allinfo)"
				echo $redepend_name $redepend_final_ver $redepuri $redepsha $redepsize $redepinstall_size
			fi
		done
		for codepend in $codepends; do
			atom_parse_type $codepend
			codepend_name=$N
			if is_installed $N $V$R; then
				local listfile=$(ypkg_getlistfile $N)
				local descfile=${listfile/.list/.desc}
				. $descfile	
				echo remove $codepend_name $INSTALL_SIZE
			fi
		done
	fi
	rm -rf $allinfo $singleinfo 2>/dev/null
}

#
do_download () {
	while [ "x$1" != "x" ]; do
		local url="$YPPATH_URI/$1"
		local pack=$YPPATH_PKGDEST/${1##*/}
		wget -q $url -O $pack.tmp
		if [ "$?" == "0" ]; then
			mv $pack.tmp $pack
		else	
			# 4 Can not connect to $YPPATH_URI
			# 8 $pack not found at $YPPATH_URI
			return "$?"
		fi
		shift 
	done
}

#
install_dev_prepare () {
	allinfo=$(yget_mktemp f)
	singleinfo=$(yget_mktemp f)
	local app="$1"
	atom_parse_type $app
	ypkg_find_info $YPPATH_UNI >$allinfo
	if [ "x$(cat $allinfo)" = "x" ]; then
		echo "app: $app not found" 1>&2
		rm -rf $allinfo $singleinfo 
		exit 1
	else	
		if [ "x$V$R" = "x" ]; then
			pack_final_ver=$(get_final_ver $N $allinfo)
			if [ "x$pack_final_ver" = "x0" ];then
				echo "app: $app not found" 1>&2
			        rm -rf $allinfo $singleinfo
				exit 1
			fi
		else
			pack_final_ver="$V$R"
		fi
		packname=$N
		atom_parse ${packname}_$pack_final_ver
		ypkg_find_info $allinfo  >$singleinfo
		bdepends="$(get_value bdepend $singleinfo)"
		rdepends="$(get_value depend $singleinfo)"
		#add dev to $rdepends 
		rdepends_ready=
		for i in $rdepends; do
			i=${i}-dev
			atom_parse ${i}
			ypkg_find_info $YPPATH_UNI >/dev/null && rdepends_ready+="${i} "
		done
		echo $bdepends $rdepends_ready
	fi
	rm -rf $allinfo $singleinfo 2>/dev/null
}


#
do_install-dev () {
	local allpacks=$(yget_mktemp f)
	local record=$(yget_mktemp f)
	while [ "x$1" != "x" ]; do
		if grep "^$1$" $record >/dev/null 2>/dev/null; then
			shift
		        continue
		fi
		install_dev_prepare "$1" >>$allpacks
	        echo "$1"  >>$record
	        shift
	done
	if [ "x$(cat $allpacks)" != "x" ]; then
		msg_  "* Install "
		wmsg "$(cat $allpacks)"
		yget install $(cat $allpacks)
	fi
	rm $allpacks $record $allpacks_ready  2>/dev/null
	return 0
}


#
do_install () {
	local allpacks=$(yget_mktemp f)
	local record=$(yget_mktemp f)
	local input="$@"
	msg "* Preparing ..."
	while [ "x$1" != "x" ]; do
		if grep "^$1$" $record >/dev/null 2>/dev/null; then
			shift
			continue
		fi
		install_prepare "$1" >>$allpacks
		echo "$1"  >>$record
		shift
	done
	#
	#
	allpacks_ready=$(yget_mktemp f)
	grep -vw "remove" $allpacks |while read pack; do
		 declare -a line=($pack)
		 name=${line[0]}
		 version=${line[1]}
		 uri=${line[2]}
		 binpack="$YPPATH_PKGDEST/${uri#*/}"
		 sha=${line[3]}
		 size=${line[4]}
		 install_size=${line[5]}
		 #
		 if [ "x$FORCE" != "xyes" ]; then
			 is_installed $name $version && continue
		 fi
		 local download="yes"
		 if [ -f $binpack ];then
			declare -a local_sha=($(sha1sum $binpack))
			local_sha=${local_sha[0]}
			[ "x$local_sha" = "x$sha" ] && download="no"
		 fi
		 if [ "x$download" != "xyes" ]; then
			uri=fill
			size=0 
		 fi
		 echo "$name $version $uri $size $install_size"  >>$allpacks_ready
	done
	if [ "x$FORCE" != "xyes" ]; then
		if [ "x$(cat $allpacks_ready)" = "x" ]; then
			echo "* $input and dependencies are up-to-date."
			return 0
		fi
	fi
	if_remove="$(grep -w remove $allpacks |awk '{print $2}' |tr '\n' ' ')"
	if [ "x$if_remove" != "x" ]; then
		msg_ "Remove: "
		msg  "$(grep -w remove $allpacks |awk '{print $2}' |tr '\n' ' ')"
		sum_remove_size=$(summation $(grep -w "remove"  $allpacks |awk '{print $3}' |tr '\n' ' '))
	fi
	if [ "x$(cat $allpacks_ready)" != "x" ]; then
		msg_ "Install: "
		msg "$(grep -vw remove $allpacks_ready |awk '{print $1}' |tr '\n' ' ')"
		sum_size=$(summation $(awk '{print $4}' $allpacks_ready |tr '\n' ' '))
		sum_inst_size=$(summation $(awk '{print $5}' $allpacks_ready |tr '\n' ' '))
		let "sum_inst_size=sum_inst_size - sum_remove_size"
		msg "Download $(convert $sum_size), require $(convert $sum_inst_size) disk space."
	fi
	if [ "x$ALWAYS_YES$PRETEND" != "xyes" ]; then
		if [ "x$PRETEND" != "xyes" ]; then
			echo "Do you want to continue [Y/n]?" 
			read yesno
		fi
	fi
	case $yesno in 
		no|n) 
		rm -r $allpacks $record $allpacks_ready 2>/dev/null
		return 1;
	esac

	local dall="$(awk '{print $3}' $allpacks_ready |sed -e '/^fill$/d' -e '/^$/d' |wc -l)"
	#ymsg "* Downloading ..."
	local count
	sep="/"
	if [ "x$dall" != "x0" ]; then
		sed '/fill 0/d' $allpacks_ready |grep -vw "remove" |awk '{print $3 " " $4}' |while read line; do
			declare -a line=($line)
			duri=${line[0]}
			dsize=${line[1]}
			let "count++"
			if [ "x$PRETEND" != "xyes" ]; then
				do_download $duri | { sleep 1
				while true;do 
					if [ -f $YPPATH_PKGDEST/${duri##*/} ]; then
						pcnt=100
						tsize=$dsize
						printf ">>% 2d%s%02d %13s % 25s %10s/%s % 10s\r" $count $sep $dall \
						       "downloading:" ${duri##*/} "$(convert $tsize)" "$(convert $dsize)" "$pcnt%"
						break
					fi
					if [ -f $YPPATH_PKGDEST/${duri##*/}.tmp ]; then
						declare -a tsize=($(du $YPPATH_PKGDEST/${duri##*/}.tmp -sb))
						tsize=${tsize[0]}
						pcnt=$(echo "scale=1; ($tsize/$dsize)*100" |bc)
						printf ">>% 2d%s%02d %13s % 25s %10s/%s % 10s\r" $count $sep $dall \
						       "downloading:" ${duri##*/} "$(convert $tsize)" "$(convert $dsize)" "$pcnt%"
					fi
					if [ -f $YPPATH_PKGDEST/${duri##*/} ]; then
						pcnt=100
						tsize=$dsize
						printf ">>% 2d%s%02d %13s % 25s %10s/%s % 10s\r" $count $sep $dall \
						       "downloading:" ${duri##*/} "$(convert $tsize)" "$(convert $dsize)" "$pcnt%"
						break
					fi
					sleep 1
				done
				}
			fi
			echo
		done
	fi
	if [ "x$DOWNLOAD_ONLY" = "xyes" ]; then
		rm -r $allpacks $record $allpacks_ready 2>/dev/null
		return 1
	fi

	psum="$(grep -v "not found" $allpacks |grep -v "remove")"
	local pall="$(grep -v "not found" $allpacks |grep -v "remove" |wc -l)"
	#ymsg "* Installing ..."
	echo
	count=
	grep -v "not found" $allpacks |grep -v "remove" |while read p; do
		declare -a uri=($p)
		name=${uri[0]}
		version=${uri[1]}
		if [ "x$FORCE" != "xyes" ]; then
			 is_installed $name $version && continue
		fi
		uri=${uri[2]}
	 	binpack="$YPPATH_PKGDEST/${uri#*/}"
		let "count++"
		uri=${uri#*/}
		uri=${uri%*.$PACK_SUFFIX}
		if [ "x$PRETEND" != "xyes" ];then
			printf ">>% 2d%s%02d %13s % 25s\n" $count $sep $pall "installing:" " $uri"
			ypkg -i $binpack 
			#if [ "x$?" = "x0" ]; then
			#	printf "% 15s\n" "installed"
			#fi
		fi
	done
	rm $allpacks $record $allpacks_ready  2>/dev/null
	return 0
}

#
do_upgrade () {
	ymsg "* Upgrade all installed packages ..."
	if [ ! -f $YPPATH_WORLD ]; then
		rmsg "Error: $YPPATH_WORLD not found."
		exit 1
	fi
	yget update
	echo 
	if [ ! -f $YPPATH_UNI ]; then
		rmsg "Error: $YPPATH_UNI not found, try:"
		echo "$0 update"
		exit 1
	fi
	ymsg "* Searching ..."
	upgrade_file=$(mktemp)
	find $YPPATH_DB/ -maxdepth 2 -type f -name "*.desc" |grep -v "\-i18n\-" |while read line;do
		atom_parse_path $line
		. $line
		#buildtime_old=$BUILD_TIME
		#[ "x$buildtime_old" = "x" ] && buildtime_old=$(cat $YPPATH_DB/$N/${N}_$V$R.date 2>/dev/null)
		old=$V$R
		flag=""
		allinfo=$(yget_mktemp f)
		singleinfo=$(yget_mktemp f)
		ypkg_find_info $YPPATH_UNI all >$allinfo
		new=$(get_final_ver $N $allinfo)
		atom_vercmp $old $new
		case $? in
			2) flag="upgrade" ;;
			#0)  
			#   #compare build time further.
			#   ypkg_find_info $YPPATH_UNI  >$singleinfo
			#   buildtime_new="$(grep "<build_date>" $singleinfo |sort -u |sed -e 's/<build_date>//g' -e 's/<\/build_date>//g' -e 's/[[:space:]]//g')"
		   	#   if [ "x$buildtime_new$buildtime_old" != "x" ]; then
			#	[ "1$buildtime_new" -gt "1$buildtime_old" ] && flag="upgrade_time"
			#   fi      ;;
	 		*) continue 
		esac
		case $flag in
			upgrade) 
				gmsg_ "[U] "
				echo "${N}_$old ----> ${N}_$new"
				echo "${N}_$old ----> ${N}_$new"  >>$upgrade_file ;;
			#upgrade_time)
			#	gmsg_ "[T] "
			#	echo "${N}_$old ----> ${N}_$new"
			#	echo "${N}_$old ----> ${N}_$new"  >>$upgrade_file ;;
				*)
				continue
		esac
	done
	num=$(cat $upgrade_file |wc -l)
	echo
	if [ "$num"0 -eq 00 ];then
		ymsg "* $num packages need to update!"
	else
		ymsg "* $num packages need to update!"
		#read -p "Do you want to continue [Y/n]?:" yorn
		echo "Do you want to continue [Y/n]?"
		read yorn
		case "x$yorn" in
			xY|xy|xyes|xYes|xYES|x)
				cat $upgrade_file |awk '{print $3}'|while read file; do
					yget install -y $file
				done	;;
		esac
	fi
	rm -rf $upgrade_file $allinfo $singleinfo
}

#
do_remove () {
	local allpacks=$(yget_mktemp f)
	local record=$(yget_mktemp f)
	msg "* Preparing ..."
	while [ "x$1" != "x" ]; do
		if grep "^$1$" $record >/dev/null 2>/dev/null; then
			shift
			continue
		fi
		app="$1"
		atom_parse_type $app
		app=$N
		if ! is_installed $N $V$R; then
			echo "app: $app not found"  1>&2
			rm $allpacks $record
			return 1
		else
			 local listfile
			 if [ "x$V$R" = "x" ]; then
				 listfile=$(ls $YPPATH_DB/$N/${N}_*.list 2>/dev/null)
			 else
		        	 listfile=$(ls $YPPATH_DB/$N/${N}_$V$R.list 2>/dev/null)
			 fi
			 atom_parse_path $listfile
			 . ${listfile%.list}.desc
			 [ "x$INSTALL_SIZE" = "x" ] && INSTALL_SIZE=$(cat ${listfile%.list}.size 2>/dev/null)
			 echo app: $N $V$R $INSTALL_SIZE  >>$allpacks
			 find_command='find $YPPATH_DB -maxdepth 2 -name "*.desc" |grep -v "\-i18n\-" |grep -v "\-dev_"'
			 eval $find_command |while read line; do
				. $line
				atom_parse_path $line
				[ "x$RDEPEND" = "x" ] && continue
				RDEPEND="${RDEPEND//,/ }"
				str_isIn "$RDEPEND" "$app" && echo remove: $N $V$R $INSTALL_SIZE >>$allpacks
			 done
			 find $YPPATH_DB -maxdepth 2 -name "$N-i18n-*.desc" |while read line; do
				. $line
				atom_parse_path $line
				echo remove: $N $V$R $INSTALL_SIZE >>$allpacks
			 done	
		fi
		echo "$1"  >>$record
		shift
	done
	sum_remove_size=$(summation $(awk '{print $4}' $allpacks |tr '\n' ' '))
	remove=($(grep ^app: $allpacks |awk '{print $2}' |tr '\n' ' '))
	remove_count=${#remove[@]}
	autoremove=($(grep ^remove: $allpacks |awk '{print $2}' |tr '\n' ' '))
	autoremove_count=${#autoremove[@]}
	echo "Remove: ${remove[@]}"
	echo "Auto-remove: ${autoremove[@]}"
	echo "After this operation, $(convert $sum_remove_size) disk space will be freed."
	if [ "x$ALWAYS_YES$PRETEND" != "xyes" ]; then
		if [ "x$PRETEND" != "xyes" ]; then
			#read -p "Do you want to continue? [y/N]" yesno
			echo "Do you want to continue [y/N]?"
			read yesno
		fi
	else
		[ "x$PRETEND" != "xyes" ] && yesno="yes" 
	fi
	case $yesno in
		Y|y|yes) 
		let "pall=remove_count+autoremove_count"
		count=1
		sep="/"
		cat $allpacks |while read pack; do
			declare -a pack=($pack)
			name=${pack[1]}
			version=${pack[2]}
			printf ">>% 2d%s%02d %13s % 25s\n" $count $sep $pall "removing:" ${name}_$version
			ypkg -C ${name}_$version >/dev/null
			let "count++"
			done	;;
		    *) 
		rm -r $allpacks $record 2>/dev/null
		return 1;
	esac
	rm -r $allpacks $record 2>/dev/null
}


# main
#

#if [ $# -lt 2 ]; then
#	usage
#	exit 0
#fi

i=0
j=0
command="$1"
second="$2"
while [ "x$2" != "x" ]; do
	case $2 in	
	-*) argvs[${j}]="$2"
	    let "j++" ;;
	*)  args[${i}]="$2"
	    let "i++"
	esac
	shift	
done

#
for ((i=0; i<${#argvs[@]}; i++)); do
	case ${argvs[i]} in
		-p) PRETEND="yes" ;;
		-y) ALWAYS_YES="yes"    ;;
		-d) DOWNLOAD_ONLY="yes" ;;
		-f) FORCE="yes"
	esac
done

#
case "$command" in
clean) 
	#clean packages dirs
	check_root
	find $YPPATH_PKGDEST -name "*.${PACK_SUFFIX}" -exec rm -v {} \;
	;;

search)
	if [ "x$second" = "x" ]; then
	       usage
	       exit 0
	fi
	for ((i=0; i<${#args[@]}; i++)); do
		do_search ${args[i]}
	done
	;;

install)
	#install binary package and depends
	if [ "x$second" = "x" ]; then
	       usage
	       exit 0
	fi
	check_root
	do_install ${args[@]}
	;;

install-dev)
	#install build-dependencies for packages
	if [ "x$second" = "x" ]; then
	       usage
	       exit 0
	fi
	check_root
	do_install-dev ${args[@]}
	;;

remove)
	#remove package
	if [ "x$second" = "x" ]; then
	       usage
	       exit 0
	fi
	check_root
	do_remove ${args[@]}
	;;

upgrade)
	#upgrade all installed packages
	check_root
	do_upgrade
	;;

update) 
	#update ypk cache
	check_root
	do_update
	;;
*)
	#show usage 
	usage
	;;
esac

#end of file
